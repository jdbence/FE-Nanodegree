'use strict';
/**
 * @description El Singleton used for manipulating DOM elements
 * @constructor
 */
var El = (function El() {
	var instance = function instance() {};

	/**
	 * @description Removes the className from each element in the array
	 * @param {array} elements - Array of DOM elements
	 * @param {string} className - Class to remove
	 */
	instance.removeClass = function removeClass(elements, className) {
		var i, c;
		if (elements) {
			if (!this.isHTMLCollection(elements)) {
				elements = [elements];
			}
			for (i = 0; i < elements.length; i++) {
				c = elements[i].className.replace(' ' + className, '');
				elements[i].className = c;
			}
		}
	};

	/**
	 * @description Adds the className on each element in the array
	 * @param {array} elements - Array of DOM elements
	 * @param {string} className - Class to add
	 */
	instance.addClass = function addClass(elements, className) {
		var i;

		if (elements) {
			if (!this.isHTMLCollection(elements)) {
				elements = [elements];
			}
			for (i = 0; i < elements.length; i++) {
				if (elements[i].className.indexOf(' ' + className) < 0) {
					elements[i].className += ' ' + className;
				}
			}
		}
	};

	/**
	 * @description Adds a listener on the element
	 * @param {array} elements - Array of DOM elements
	 * @param {string} event - Event to listen for
	 * @param {function} callback - Function to call when the event is captured
	 */
	instance.addListener = function addListener(elements, event, callback) {
		var i;

		if (elements) {
			if (elements.length === undefined) {
				elements = [elements];
			}
			for (i = 0; i < elements.length; i++) {
				elements[i].addEventListener(event, callback);
			}
		}
	};

	/**
	 * @description Removes the hidden class from the elements with the given className or #ID
	 * @param {string} identifier - The elements to find
	 */
	instance.show = function show(identifier) {
		this.removeClass(this.getElements(identifier), 'hidden');
	};

	/**
	 * @description Adds the hidden class on the elements with the given className or #ID
	 * @param {string} identifier - The elements to find
	 */
	instance.hide = function hide(identifier) {
		this.addClass(this.getElements(identifier), 'hidden');
	};

	/**
	 * @description Finds all the elements with the className or #ID
	 * @param {string} identifier - The elements to find
	 */
	instance.getElements = function getElements(identifier) {
		if (this.isString(identifier)) {
			if (identifier.indexOf('#') !== -1) {
				return document.getElementById(identifier);
			}
			return document.getElementsByClassName(identifier);
		}
		return null;
	};

	/**
	 * @description Checks if the variable is a string
	 * @param {string} variable - The variable to check
	 */
	instance.isString = function isString(variable) {
		return this.isType(variable, '[object String]');
	};

	/**
	 * @description Checks if the variable is a HTMLCollection
	 * @param {string} variable - The variable to check
	 */
	instance.isHTMLCollection = function isHTMLCollection(variable) {
		return this.isType(variable, '[object HTMLCollection]');
	};

	/**
	 * @description Checks if the variable is the type
	 * @param {string} variable - The variable to check
	 */
	instance.isType = function isType(variable, type) {
		return Object.prototype.toString.call(variable) === type;
	};

	return instance;
})();

'use strict';
/**
* @description Entity sets all default variables to the owner
* @constructor
* @param {object} owner - The initial row
* @param {number} x - The initial x location
* @param {number} y - The initial y location
* @param {string} sprite - The display sprite
* @param {number} offsetX - The initial x offset
* @param {number} offsetY - The initial y offset
*/
var Entity = function Entity(owner, x, y, sprite, offsetX, offsetY) {
	this.owner = owner;
	owner.x = x;
	owner.y = y;
	owner.sprite = sprite || null;
	owner.offsetX = offsetX || 0;
	owner.offsetY = offsetY || 0;
	owner.flipped = false;
	owner.alpha = 1;
	owner.isAlive = true;
	owner.speed = 0;
	owner.angle = 0;
};

'use strict';
/* Resources.js
 * This is simple an image loading utility. It eases the process of loading
 * image files so that they can be used within your game. It also includes
 * a simple "caching" layer so it will reuse cached images if you attempt
 * to load the same image multiple times.
 */
(function Resources() {
	var resourceCache = {};
	var loading = [];
	var readyCallbacks = [];

	/* This is the publicly accessible image loading function. It accepts
	   * an array of strings pointing to image files or a string for a single
	   * image. It will then call our private image loading function accordingly.
	   */
	function load(urlOrArr) {
		if (urlOrArr instanceof Array) {
			/* If the developer passed in an array of images
			       * loop through each value and call our image
			       * loader on that image file
			       */
			urlOrArr.forEach(function(url) {
				_load(url);
			});
		} else {
			/* The developer did not pass an array to this function,
			       * assume the value is a string and call our image loader
			       * directly.
			       */
			_load(urlOrArr);
		}
	}

	/* This is our private image loader function, it is
	   * called by the public image loader function.
	   */
	function _load(url) {
		if (resourceCache[url]) {
			/* If this URL has been previously loaded it will exist within
			       * our resourceCache array. Just return that image rather
			       * re-loading the image.
			       */
			return resourceCache[url];
		} else {
			/* This URL has not been previously loaded and is not present
			       * within our cache; we'll need to load this image.
			       */
			var img = new Image();
			img.onload = function() {
				/* Once our image has properly loaded, add it to our cache
				         * so that we can simply return this image if the developer
				         * attempts to load this file in the future.
				         */
				resourceCache[url] = img;

				/* Once the image is actually loaded and properly cached,
				         * call all of the onReady() callbacks we have defined.
				         */
				if (isReady()) {
					readyCallbacks.forEach(function(func) { func(); });
				}
			};

			/* Set the initial cache value to false, this will change when
			       * the image's onload event handler is called. Finally, point
			       * the images src attribute to the passed in URL.
			       */
			resourceCache[url] = false;
			img.src = url;
		}
	}

	/* This is used by developer's to grab references to images they know
	   * have been previously loaded. If an image is cached, this functions
	   * the same as calling load() on that URL.
	   */
	function get(url) {
		return resourceCache[url];
	}

	/* This function determines if all of the images that have been requested
	   * for loading have in fact been completed loaded.
	   */
	function isReady() {
		var ready = true;
		for (var k in resourceCache) {
			if (resourceCache.hasOwnProperty(k) &&
			!resourceCache[k]) {
				ready = false;
			}
		}
		return ready;
	}

	/* This function will add a function to the callback stack that is called
	   * when all requested images are properly loaded.
	   */
	function onReady(func) {
		readyCallbacks.push(func);
	}

	/* This object defines the publicly accessible functions available to
	   * developers by creating a global Resources object.
	   */
	window.Resources = {
		load: load,
		get: get,
		onReady: onReady,
		isReady: isReady
	};
})();

'use strict';
/**
 * @description Collision Singleton used for checking collision between two sensors
 * @constructor
 */
var Collision = (function Prototype() {
	var instance = function instance() {};
	/**
	 * @description Uses box collision to check if two sensors are touching
	 * @param {Senor} sensorA - Bounding rect A
	 * @param {Senor} sensorB - Bounding rect B
	 * @returns {boolean} based on sensor overlap
	 */
	instance.isColliding = function isColliding(sensorA, sensorB) {
		return (sensorA.x < sensorB.x + sensorB.width &&
			sensorA.x + sensorB.width > sensorB.x &&
			sensorA.y < sensorB.y + sensorB.height &&
			sensorA.height + sensorA.y > sensorB.y);
	};
	return instance;
})();

'use strict';
/* Engine.js
 * This file provides the game loop functionality (update entities and render),
 * draws the initial game board on the screen, and then calls the update and
 * render methods on your player and enemy objects (defined in your app.js).
 *
 * A game engine works by drawing the entire game screen over and over, kind of
 * like a flipbook you may have created as a kid. When your player moves across
 * the screen, it may look like just that image/character is moving or being
 * drawn but that is not the case. What's really happening is the entire "scene"
 * is being drawn over and over, presenting the illusion of animation.
 *
 * This engine is available globally via the Engine variable and it also makes
 * the canvas' context (ctx) object globally available to make writing app.js
 * a little simpler to work with.
 */

var Engine = (function Engine(global) {
	/* Predefine the variables we'll be using within this scope,
	   * create the canvas element, grab the 2D context for that canvas
	   * set the canvas elements height/width and add it to the DOM.
	   */
	var doc = global.document,
	win = global.window,
	canvas = doc.createElement('canvas'),
	ctx = canvas.getContext('2d'),
	lastTime,
	running = false,
	instance = function instance() {};

	instance.entities = [];
	instance.width = canvas.width = 505;
	instance.height = canvas.height = 606;
	canvas.className += ' canvas-game';
	doc.getElementsByClassName('level')[0].appendChild(canvas);

	/* This is called by the update function  and loops through all of the
	   * objects within your instance.entities array as defined in app.js and calls
	   * their update() methods. It will then call the update function for your
	   * player object. These update methods should focus purely on updating
	   * the data/properties related to  the object. Do your drawing in your
	   * render methods.
	   */
	function updateEntities(dt) {
		instance.entities.forEach(function EachEnemy(enemy) {
			enemy.update(dt);
		});
		player.update(dt);
	}

	/* This function is called by main (our game loop) and itself calls all
	   * of the functions which may need to update entity's data. Based on how
	   * you implement your collision detection (when two entities occupy the
	   * same space, for instance when your character should die), you may find
	   * the need to add an additional function call here. For now, we've left
	   * it commented out - you may or may not want to implement this
	   * functionality this way (you could just implement collision detection
	   * on the entities themselves within your app.js file).
	   */
	function update(dt) {
		updateEntities(dt);
		// checkCollisions();
	}

	/* This function is called by the render function and is called on each game
	   * tick. It's purpose is to then call the render functions you have defined
	   * on your enemy and player entities within app.js
	   */
	function renderEntities() {
		/* Loop through all of the objects within the instance.entities array and call
		     * the render function you have defined.
		     */
		var i;
		for (i = 0; i < instance.entities.length; i++) {
			instance.entities[i].render(ctx);
		}

		player.render(ctx);
	}

	/* This function initially draws the "game level", it will then call
	   * the renderEntities function. Remember, this function is called every
	   * game tick (or loop of the game engine) because that's how games work -
	   * they are flipbooks creating the illusion of animation but in reality
	   * they are just drawing the entire screen over and over.
	   */
	function render() {
		/* This array holds the relative URL to the image used
		     * for that particular row of the game level.
		     */
		var rowImages = [
		'images/water-block.png',   // Top row is water
		'images/stone-block.png',   // Row 1 of 3 of stone
		'images/stone-block.png',   // Row 2 of 3 of stone
		'images/stone-block.png',   // Row 3 of 3 of stone
		'images/grass-block.png',   // Row 1 of 2 of grass
		'images/grass-block.png'    // Row 2 of 2 of grass
		],
		numRows = 6,
		numCols = 5,
		row, col;

		//  Clear the entire canvas
		ctx.clearRect(0, 0, canvas.width, canvas.height);

		/* Loop through the number of rows and columns we've defined above
		     * and, using the rowImages array, draw the correct image for that
		     * portion of the "grid"
		     */
		for (row = 0; row < numRows; row++) {
			for (col = 0; col < numCols; col++) {
				/* The drawImage function of the canvas' context element
				         * requires 3 parameters: the image to draw, the x coordinate
				         * to start drawing and the y coordinate to start drawing.
				         * We're using our Resources helpers to refer to our images
				         * so that we get the benefits of caching these images, since
				         * we're using them over and over.
				         */
				ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);
			}
		}

		renderEntities();
	}
	
	/* This function serves as the kickoff point for the game loop itself
	   * and handles properly calling the update and render methods.
	   */
	function main() {
		if (running) {
			/* Get our time delta information which is required if your game
			       * requires smooth animation. Because everyone's computer processes
			       * instructions at different speeds we need a constant value that
			       * would be the same for everyone (regardless of how fast their
			       * computer is) - hurray time!
			       */
			var now = Date.now(),
			dt = (now - lastTime) / 1000.0;

			/* Call our update/render functions, pass along the time delta to
			 * our update function since it may be used for smooth animation.
			 */
			update(dt);
			render();

			/* Set our lastTime variable which is used to determine the time delta
			 * for the next time this function is called.
			 */
			lastTime = now;

			/* Use the browser's requestAnimationFrame function to call this
			 * function again as soon as the browser is able to draw another frame.
			 */
			win.requestAnimationFrame(main);
		}
	}

	/* This function does some initial setup that should only occur once,
	   * particularly setting the lastTime variable that is required for the
	   * game loop.
	   */
	function init() {
		instance.reset();
		running = true;
		lastTime = Date.now();
		main();
	}

	/* This function does nothing but it could have been a good place to
	   * handle game reset states - maybe a new game menu or a game over screen
	   * those sorts of things. It's only called once by the init() method.
	   */
	instance.reset = function reset() {
		running = false;
	};

	instance.pause = function pause() {
		running = false;
	};

	instance.preload = function preload() {
		/* Go ahead and load all of the images we know we're going to need to
		     * draw our game level. Then set init as the callback method, so that when
		     * all of these images are properly loaded our game will start.
		     */

		function locations(folder, format) {
			var resources = [
			'char-boy',
			'char-cat-girl',
			'char-horn-girl',
			'char-pink-girl',
			'char-princess-girl',
			'enemy-bug',
			'Gem Blue',
			'Gem Green',
			'Gem Orange',
			'grass-block',
			'Heart',
			'Key',
			'Rock',
			'Selector',
			'Star',
			'stone-block',
			'water-block'
			];
			return resources.map(function resourceMap(el) {
				return folder + el + '.' + format;
			});
		}
		Resources.load(locations('images/', 'png'));

		if (Resources.isReady()) {
			init();
		}else {
			Resources.onReady(init);
		}
	};

	/* Assign the canvas' context object to the global variable (the window
	   * object when run in a browser) so that developer's can use it more easily
	   * from within their app.js files.
	   */
	global.ctx = ctx;

	return instance;
})(this);

'use strict';
/**
* @description Model Singleton used for storing state data
* @constructor
*/
var Model = (function Model() {
	var data = {};
	var instance = function instance() {};

	/**
	 * @description Sets a value to a key
	 * @param {string} key - The property to store the value under
	 * @param {number} value - The value of the key
	 * @returns {*} The value of the key
	 */
	instance.set = function set(key, value) {
		data[key] = value;
		return value;
	};

	/**
	 * @description Returns the value set to the key
	 * @returns {*} The value of the key
	 */
	instance.get = function get(key) {
		return data[key];
	};

	return instance;
})();

'use strict';
/**
* @description A Timer class that updates manually using with delta time
* @constructor
*/
var Timer = function Timer(intervals, delay) {
	this.intervals = intervals;
	this.delay = delay;
	this.running = false;
	this.listeners = {};
	this.time = 0;
	this.laps = 0;
};

(function Prototype() {
	/**
	 * @description Resets the timer and flags it as running
	 */
	this.start = function start() {
		this.running = true;
		this.time = this.delay;
		this.laps = this.intervals;
	};

	/**
	 * @description Uses the delta time to manually update the timer
	 * @param {number} delta - Time since last update
	 */
	this.update = function update(delta) {
		if (this.running) {
			this.time = Math.max(0, this.time - delta);
			if (this.time === 0) {
				this.laps -= 1;
				if (this.laps <= 0) {
					this.running = false;
					this.dispatch('COMPLETE');
				}else {
					this.time = this.delay;
					this.dispatch('UPDATE');
				}
			}
		}
	};

	/**
	 * @description Adds a listener for the specified event
	 * @param {string} event - The event to listen for
	 * @param {function} listener - The callback function
	 */
	this.on = function on(event, listener) {
		if (!this.listeners.hasOwnProperty(event)) {
			this.listeners[event] = [];
		}
		this.listeners[event].push(listener);
	};

	/**
	 * @description Attempts to invoke a callback method for the given event
	 * @param {string} event - The event to dispatch
	 */
	this.dispatch = function dispatch(event) {
		var i;
		var list;
		if (this.listeners.hasOwnProperty(event)) {
			list = this.listeners[event];
			for (i = 0; i < list.length; i++) {
				list[i](this);
			}
		}
	};
}).call(Timer.prototype);

'use strict';
/**
* @description Grid Singleton used for positioning things on a Grid
* @constructor
*/
var Grid = (function Grid() {
	var instance = function instance() {};

	instance.cellWidth = 101;
	instance.cellHeight = 83;
	instance.columns = 5;
	instance.rows = 6;
	instance.offsetY = 50;

	/**
	 * @description Determines the x location based on the column
	 * @param {int} column - The column
	 * @returns {number} The screen x position
	 */
	instance.getXFromColumn = function getXFromColumn(column) {
		var col = Math.max(0, Math.min(column, instance.columns - 1));
		return col * instance.cellWidth;
	};

	/**
	 * @description Determines the y location based on the row
	 * @param {int} row - The row
	 * @returns {number} The screen y position
	 */
	instance.getYFromRow = function getYFromRow(row) {
		row = Math.max(0, Math.min(row, instance.rows - 1));
		return instance.offsetY + row * instance.cellHeight;
	};

	return instance;
})();

'use strict';
/**
* @description Handles level creation
* @constructor
*/
var Level = function Level() {
	this.reset();
};

(function Prototype() {
	/**
	 * @description Reset's level variables to original values
	 */
	this.reset = function reset() {
		this.level = Model.set('level', 0);
		this.lastLevel = 7;
		Model.set('level_total_time', 15);
		Model.set('level_complete', false);
	};

	/**
	 * @description Advances the current level by one
	 */
	this.next = function next() {
		this.level = Model.set('level', this.level + 1);
	};

	/**
	 * @description Creates all the entities for the current level
	 */
	this.addEntities = function addEntities() {
		var data = this.levelData();
		var i;
		Engine.entities = [];

		for (i = 0; i < data.length; i++) {
			if (data[i].hasOwnProperty('t')) {
				if (data[i].t === 'key') {
					Engine.entities.push(new Key(data[i].r, data[i].c));
				}else if (data[i].t === 'water') {
					Engine.entities.push(new Water(data[i].r, data[i].c));
				}
			}else {
				Engine.entities.push(new Enemy(data[i].r, data[i].c, data[i].s));
			}
		}
	};

	/**
	 * @description Returns the JSON entities for the given level
	 * @returns {array}
	 */
	this.levelData = function levelData() {
		//  Formatted so it's easier to see the levels (not following Udacity JS standards)
		//  jscs:disable
		if (this.level === 0) {
			return [
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 1) {
			return [
			{r: 3, c: 0, s: 200}, {r: 3, c: 2, s: 200}, {r: 3, c: 4, s: 200},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 2) {
			return [
			{r: 1, c: 0, s: -100}, {r: 1, c: 1, s: -100}, {r: 1, c: 3, s: -100}, {r: 1, c: 4, s: -100},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 3) {
			return [
			{r: 2, c: 0, s: 500}, {r: 2, c: 4, s: 600},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 4) {
			return [
			{r: 1, c: 0, s: -100}, {r: 1, c: 1, s: -100}, {r: 1, c: 3, s: -100}, {r: 1, c: 4, s: -100},
			{r: 3, c: 0, s: 200}, {r: 3, c: 2, s: 200}, {r: 3, c: 4, s: 200},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 5) {
			return [
			{r: 2, c: 0, s: 500}, {r: 2, c: 4, s: 600},
			{r: 3, c: 0, s: 200}, {r: 3, c: 2, s: 200}, {r: 3, c: 4, s: 200},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 6) {
			return [
			{r: 1, c: 0, s: -100}, {r: 1, c: 1, s: -100}, {r: 1, c: 3, s: -100}, {r: 1, c: 4, s: -100},
			{r: 2, c: 0, s: 500}, {r: 2, c: 4, s: 600},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}
		//  jscs:disable
		return [
		{r: 1, c: 0, s: -100}, {r: 1, c: 1, s: -100}, {r: 1, c: 3, s: -100}, {r: 1, c: 4, s: -100},
		{r: 2, c: 0, s: 500}, {r: 2, c: 4, s: 600},
		{r: 3, c: 0, s: 200}, {r: 3, c: 2, s: 200}, {r: 3, c: 4, s: 200},
		{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
		];
	};
}).call(Level.prototype);

'use strict';
/**
 * @description Scene Singleton used for changing the scene view
 * @constructor
 */
var Scene = (function Scene() {
	var instance = function instance() {};
	var level = new Level();
	var onCharacterClicked = function onCharacterClicked(el) {
		var s = el.target.src;
		player.sprite = s.slice(s.indexOf('/images/') + 1, s.length);

		El.removeClass(El.getElements('selected-char'), 'selected-char');
		El.addClass(el.target, 'selected-char');
	};
	/**
	 * @description Shows the Character selection scene
	 */
	instance.startMenu = function startMenu() {
		var characters = document.getElementsByClassName('char');
		var i;

		for (i = 0; i < characters.length; i++) {
			characters[i].addEventListener('click', onCharacterClicked);
		}

		Engine.reset();

		El.show('char_select');
		El.hide('level');
		El.hide('gameover');
		El.hide('gamewin');
		scene = 'char_select';
	};

	/**
	 * @description Shows the Game scene
	 */
	instance.startGame = function startGame(reset) {
		reset = reset || false;

		if (reset) {
			level.reset();
		} else {
			Model.set('level_complete', false);
		}

		Engine.preload();
		player.respawn();

		level.addEntities();
		Engine.entities.push(ui);
		ui.start();

		El.show('level');
		El.hide('char_select');
		El.hide('gameover');
		El.hide('gamewin');
		scene = 'level';
	};

	/**
	 * @description Shows the Game Over popup
	 */
	instance.endGame = function endGame() {
		El.show('gameover');
		Engine.pause();
	};

	/**
	 * @description Shows the Game Win popup
	 */
	instance.winGame = function winGame() {
		El.show('gamewin');
		Engine.pause();
	};

	/**
	 * @description The player picked up the key. Show star explosion and advance level after timeout
	 */
	instance.levelComplete = function levelComplete() {
		Model.set('level_complete', true);
		Engine.entities.push(new Explosion(0, 2));
		setTimeout(instance.nextLevel, 1500);
	};

	/**
	 * @description Advance to the next level or end the game if no more levels
	 */
	instance.nextLevel = function nextLevel() {
		level.next();

		if (level.level > level.lastLevel) {
			instance.winGame();
		} else {
			instance.startGame();
		}
	};

	return instance;
})();

'use strict';
/**
* @description A sensor used as a collision box that can be rendered to the screen for testing
* @constructor
* @param {number} x - The x location
* @param {number} y - The y location
* @param {number} width - How long the sensor is
* @param {number} height - How tall the sensor is
* @param {number} offsetX - The offset in the x direction
* @param {number} offsetY - The offset in the y direction
*/
var Sensor = function Sensor(x, y, width, height, offsetX, offsetY) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.offsetX = offsetX;
	this.offsetY = offsetY;
	this.debug = false;
};

(function Prototype() {
	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		if (this.debug) {
			ctx.beginPath();
			ctx.strokeStyle = 'red';
			ctx.rect(this.x, this.y, this.width, this.height);
			ctx.stroke();
		}
	};

	/**
	 * @description Updates the sensor's position
	 * @param {int} x - The x location
	 * @param {int} y - The y location
	 */
	this.position = function position(x, y) {
		this.x = x + this.offsetX;
		this.y = y + this.offsetY;
	};
}).call(Sensor.prototype);

'use strict';
/**
* @description A component that renders the owners sprite according to position, alpha and direction
* @constructor
*/
var Render = function Render(owner) {
	this.owner = owner;
};

(function Prototype() {
	var p = {x: 0, y: 0};
	/**
	  * @description Renders the owner's sprite
	  * @param {context} ctx - The canvas's context
	  */
	this.render = function render(ctx) {
		var flipped = this.owner.flipped ? -1 : 1;
		var pos = this.getPosition();
		ctx.save();
		ctx.scale(flipped, 1);
		ctx.globalAlpha = this.owner.alpha || 1;
		ctx.drawImage(Resources.get(this.owner.sprite), pos.x, pos.y, 101, 171);
		ctx.restore();
	};

	/**
	  * @description Returns the formatted position
	  */
	this.getPosition = function getPosition() {
		var flipped = this.owner.flipped ? -1 : 1;
		p.x = (this.owner.x + this.owner.offsetX) * flipped;
		p.x += (flipped === 1 ? 0 : -101);
		p.y = this.owner.y + this.owner.offsetY;
		return p;
	};
}).call(Render.prototype);

'use strict';
/**
* @description The ingame information display
* @constructor
*/
var UI = function UI() {
	this.keys = 0;
	this.levelTime = 0;
	this.time = 0;
};

(function Prototype() {
	/**
	 * @description Resets the level information and starts the game timer
	 */
	this.start = function start() {
		this.keys = Model.get('level');
		this.levelTime = Model.get('level_total_time');

		this.levelTimer = new Timer(1, this.levelTime);
		this.levelTimer.on('COMPLETE', this.onTimerComplete);
		this.levelTimer.start();
	};

	/**
	 * @description The level timer has completed
	 */
	this.onTimerComplete = function onTimerComplete() {
		if (!Model.get('level_complete')) {
			Scene.endGame();
		}
	};

	/**
	 * @description Formated string of time left (expects >0 && <60 seconds)
	 * @returns {string} Seconds left on time
	 */
	this.formattedTime = function formattedTime() {
		var time = Math.round(this.levelTimer.time);
		return '00:' + (time > 9 ? time : '0' + time);
	};

	/**
	 * @description Renders text to the screen
	 * @param {context} ctx - The canvas's context
	 * @param {string} string - The string to display
	 * @param {number} x - The x location
	 * @param {number} y - The y location
	 * @param {string} align - The canvas's context
	 */
	this.text = function text(ctx, string, x, y, align) {
		ctx.save();
		ctx.font = '30px Comic Sans MS';
		if (align === 'left' || align === 'right' || align === 'center') {
			ctx.textAlign = align;
		}
		ctx.fillText(string, x, y);
		ctx.restore();
	};

	/**
	 * @description Updates the timer and key information
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		if (!Model.get('level_complete')) {
			this.keys = Model.get('level');
			this.levelTimer.update(dt);
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.text(ctx, 'Keys: x' + this.keys, 0, 30);
		this.text(ctx, 'Time: ' + this.formattedTime(), Engine.width, 30, 'right');
	};
}).call(UI.prototype);

'use strict';
/**
* @description Key entity
* @constructor
* @param {int} row - The initial row
* @param {int} col - The initial column
*/
var Key = function Key(row, col) {
	this.entity = new Entity(this,
		Grid.getXFromColumn(col),
		Grid.getYFromRow(row),
		'images/Key.png',
		0,
		-(171 - 138) - Grid.offsetY);
	this.sensor = new Sensor(0, 0, 50, 30, 25, 25);
	this.renderer = new Render(this);
};

(function Prototype() {
	/**
	 * @description Checks if this entity is colliding with the player
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.sensor.position(this.x, this.y);
		if (player && player.isAlive && this.isAlive) {
			if (Collision.isColliding(this.sensor, player.sensor)) {
				this.isAlive = false;
				player.hit('key');
			}
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.renderer.render(ctx);
		this.sensor.render(ctx);
	};
}).call(Key.prototype);

'use strict';
/**
* @description Water entity
* @constructor
* @param {int} row - The initial row
* @param {int} col - The initial column
*/
var Water = function Water(row, col) {
	this.entity = new Entity(this,
		Grid.getXFromColumn(col),
		Grid.getYFromRow(row),
		'images/Key.png',
		0,
		-(171 - 138) - Grid.offsetY);
	this.sensor = new Sensor(0, 0, 50, 30, 25, 25);
};

(function Prototype() {
	/**
	 * @description Checks if this entity is colliding with the player
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.sensor.position(this.x, this.y);

		if (player && player.isAlive) {
			if (Collision.isColliding(this.sensor, player.sensor)) {
				player.hit('water');
			}
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.sensor.render(ctx);
	};
}).call(Water.prototype);

'use strict';
/**
 * @description Enemy entity
 * @constructor
 * @param {int} row - The initial row
 * @param {int} col - The initial column
 * @param {number} speed - The initial speed
 */
var Enemy = function Enemy(row, col, speed) {
	this.entity = new Entity(this,
		Grid.getXFromColumn(col),
		Grid.getYFromRow(row),
		'images/enemy-bug.png',
		0, -(171 - 138) - Grid.offsetY);
	this.row = row;
	this.speed = speed;
	this.flipped = speed < 0;
	this.sensor = new Sensor(0, 0, 50, 50, 25, 12);
	this.renderer = new Render(this);
};

(function Prototype() {
	/**
	 * @description Checks if this entity is colliding with the player and keeps target on screen by wrapping x location
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.x += dt * this.speed;

		//  Wrap
		if (this.x > (Grid.columns * Grid.cellWidth) + Grid.cellWidth) {
			this.x = Grid.getXFromColumn(0) - Grid.cellWidth;
		} else if (this.x < -Grid.cellWidth) {
			this.x = (Grid.columns * Grid.cellWidth) + Grid.cellWidth;
		}

		this.sensor.position(this.x, this.y);
		if (player && player.isAlive) {
			if (Collision.isColliding(this.sensor, player.sensor)) {
				player.hit('enemy');
			}
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.renderer.render(ctx);
		this.sensor.render(ctx);
	};
}).call(Enemy.prototype);

'use strict';
/**
* @description Player entity
* @constructor
*/
var Player = function Player() {
	this.entity = new Entity(this,
		0,
		0,
		'images/char-boy.png',
		0,
		-(171 - 138) - Grid.offsetY);
	this.isAlive = false;
	this.alpha = 0;
	this.sensor = new Sensor(0, 0, 50, 30, 25, 25);
	this.renderer = new Render(this);
	this.blinkTimer = new Timer(5, 0.2);

	var ref = this;

	var onBlinkTimerComplete = function onBlinkTimerComplete() {
		ref.alpha = 1;
		ref.isAlive = true;
	};

	var onBlinkTimerUpdate = function onBlinkTimerUpdate() {
		ref.alpha = (ref.alpha === 0.4 ? 1 : 0.4);
	};

	var onKeyUp = function onKeyUp(e) {
		ref.handleInput(e);
	};

	this.blinkTimer.on('COMPLETE', onBlinkTimerComplete);
	this.blinkTimer.on('UPDATE', onBlinkTimerUpdate);
	document.addEventListener('keyup', onKeyUp);

	this.respawn();
};

(function Prototype() {
	var inputMap = {
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down'
	};

	var inputResponseMap = {
		left: {axis: 'x', dir: -1},
		up: {axis: 'y', dir: -1},
		right: {axis: 'x', dir: 1},
		down: {axis: 'y', dir: 1}
	};

	/**
	 * @description Resets the player to the initial position
	 */
	this.respawn = function respawn() {
		this.sensor.x = this.x = Grid.getXFromColumn(2);
		this.sensor.y = this.y = Grid.getYFromRow(5);
		this.isAlive = false;
		this.alpha = 0.4;
		this.blinkTimer.start();
	};

	/**
	 * @description A entity has hit the player
	 * @param {string} invoker - Type of object that hit the player
	 */
	this.hit = function hit(invoker) {
		if (invoker === 'water' || invoker === 'enemy') {
			this.respawn();
		}else if (invoker === 'key') {
			Scene.levelComplete();
		}
	};

	/**
	 * @description Gets the position on the grid based on player's input
	 * @param {string} axis - The x or y axis
	 * @param {input} dir - The positive or negative direction
	 * @returns {number} The final position
	 */
	this.getMovement = function getMovement(axis, dir) {
		var v;

		if (axis === 'x') {
			v = Math.floor(this.x / Grid.cellWidth) + dir;
			return Grid.getXFromColumn(v);
		}

		v = Math.floor(this.y / Grid.cellHeight) + dir;
		return Grid.getYFromRow(v);
	};

	/**
	 * @description Changes the player position based on input
	 * @param {event} e - The event that occured
	 */
	this.handleInput = function handleInput(e) {
		var input = inputMap[e.keyCode];
		if (input && this.isAlive === true && !Model.get('level_complete')) {
			var map = inputResponseMap[input];

			//  Movement
			if (map.hasOwnProperty('axis')) {
				this[map.axis] = this.getMovement(map.axis, map.dir);
			}
		}
	};

	/**
	 * @description Updates the players timer and sensor
	 * @param {number} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.sensor.position(this.x, this.y);
		if (!this.isAlive) {
			this.blinkTimer.update(dt);
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.renderer.render(ctx);
		this.sensor.render(ctx);
	};
}).call(Player.prototype);

'use strict';
/**
* @description Star entity
* @constructor
* @param {int} row - The initial row
* @param {int} col - The initial column
*/
var Star = function Star(row, col) {
	this.entity = new Entity(this,
		Grid.getXFromColumn(col),
		Grid.getYFromRow(row),
		'images/Star.png',
		0,
		-(171 - 138) - Grid.offsetY);
	this.renderer = new Render(this);
	this.speed = 500;
	this.angle = Math.round(Math.random() * 180) * Math.PI / 180;
};

(function Prototype() {
	/**
	 * @description Moves the star in the direction of the angle and lowers opacity
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.x += this.speed * Math.cos(this.angle) * dt;
		this.y += this.speed * Math.sin(this.angle) * dt;
		this.alpha = Math.max(0.01, this.alpha - 1 * dt);
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.renderer.render(ctx);
	};
}).call(Star.prototype);

'use strict';
/**
* @description Key entity
* @constructor
* @param {int} row - The initial row
* @param {int} col - The initial column
*/
var Explosion = function Explosion(row, col){
    this.stars = [];
    this.addStars(row, col, 10);
};

(function Prototype() {
    
    /**
    * @description Adds the stars
    * @param {int} row - The y location
    * @param {int} col - The x location
    * @param {int} total - Amount of stars
    */
    this.addStars = function addStars(row, col, total){
        var i;
        for(i=0; i<total; i++){
            this.stars.push(new Star(row, col));
        }
    }

    /**
    * @description Moves all the stars
    * @param {int} dt - Time since last update
    */
    this.update = function update(dt) {
        var total = this.stars.length;
        var i;
        if(total > 0){
            if(this.stars[0].alpha <= 0.01){
                this.stars = [];
            }else{
                for(i=0; i<total; i++){
                    this.stars[i].update(dt);
                }
            }
        }
    };
    
    /**
    * @description Renders the stars to the canvas
    * @param {context} ctx - The canvas's context
    */
    this.render = function render(ctx) {
        var total = this.stars.length;
        var i;
        for(i=0; i<total; i++){
            this.stars[i].render(ctx);
        }
    };

}).call(Explosion.prototype);
'use strict';
var Scene = Scene || {};
var El = El || {};
var UI = UI || {};
var Player = Player || {};
var player = new Player();
var ui = new UI();
var scene = '';
var App = (function App() {
	var onPlayClicked = function onPlayClicked() {
		Scene.startGame(true);
	};
	var onReplayClicked = function onReplayClicked() {
		Scene.startGame();
	};
	var onMenuClicked = function onMenuClicked() {
		Scene.startMenu();
	};

	El.addListener(El.getElements('btn-play')[0], 'click', onPlayClicked);
	El.addListener(El.getElements('btn-replay')[0], 'click', onReplayClicked);
	El.addListener(El.getElements('btn-menu'), 'click', onMenuClicked);

	//	Default show the start menu
	Scene.startMenu();
	//	Scene.startGame();
})();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsLmpzIiwiZW50aXR5LmpzIiwicmVzb3VyY2VzLmpzIiwiY29sbGlzaW9uLmpzIiwiZW5naW5lLmpzIiwibW9kZWwuanMiLCJ0aW1lci5qcyIsImdyaWQuanMiLCJsZXZlbC5qcyIsInNjZW5lLmpzIiwic2Vuc29yLmpzIiwicmVuZGVyLmpzIiwidWkuanMiLCJrZXkuanMiLCJ3YXRlci5qcyIsImVuZW15LmpzIiwicGxheWVyLmpzIiwic3Rhci5qcyIsImV4cGxvc2lvbi5qcyIsImFwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhcHAubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gRWwgU2luZ2xldG9uIHVzZWQgZm9yIG1hbmlwdWxhdGluZyBET00gZWxlbWVudHNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRWwgPSAoZnVuY3Rpb24gRWwoKSB7XG5cdHZhciBpbnN0YW5jZSA9IGZ1bmN0aW9uIGluc3RhbmNlKCkge307XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHRoZSBjbGFzc05hbWUgZnJvbSBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5XG5cdCAqIEBwYXJhbSB7YXJyYXl9IGVsZW1lbnRzIC0gQXJyYXkgb2YgRE9NIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgLSBDbGFzcyB0byByZW1vdmVcblx0ICovXG5cdGluc3RhbmNlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudHMsIGNsYXNzTmFtZSkge1xuXHRcdHZhciBpLCBjO1xuXHRcdGlmIChlbGVtZW50cykge1xuXHRcdFx0aWYgKCF0aGlzLmlzSFRNTENvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG5cdFx0XHRcdGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcblx0XHRcdH1cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjID0gZWxlbWVudHNbaV0uY2xhc3NOYW1lLnJlcGxhY2UoJyAnICsgY2xhc3NOYW1lLCAnJyk7XG5cdFx0XHRcdGVsZW1lbnRzW2ldLmNsYXNzTmFtZSA9IGM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gQWRkcyB0aGUgY2xhc3NOYW1lIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXlcblx0ICogQHBhcmFtIHthcnJheX0gZWxlbWVudHMgLSBBcnJheSBvZiBET00gZWxlbWVudHNcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAtIENsYXNzIHRvIGFkZFxuXHQgKi9cblx0aW5zdGFuY2UuYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50cywgY2xhc3NOYW1lKSB7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoZWxlbWVudHMpIHtcblx0XHRcdGlmICghdGhpcy5pc0hUTUxDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuXHRcdFx0XHRlbGVtZW50cyA9IFtlbGVtZW50c107XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGVsZW1lbnRzW2ldLmNsYXNzTmFtZS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSkgPCAwKSB7XG5cdFx0XHRcdFx0ZWxlbWVudHNbaV0uY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIEFkZHMgYSBsaXN0ZW5lciBvbiB0aGUgZWxlbWVudFxuXHQgKiBAcGFyYW0ge2FycmF5fSBlbGVtZW50cyAtIEFycmF5IG9mIERPTSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBFdmVudCB0byBsaXN0ZW4gZm9yXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyBjYXB0dXJlZFxuXHQgKi9cblx0aW5zdGFuY2UuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcihlbGVtZW50cywgZXZlbnQsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoZWxlbWVudHMpIHtcblx0XHRcdGlmIChlbGVtZW50cy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRlbGVtZW50cyA9IFtlbGVtZW50c107XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZWxlbWVudHNbaV0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgdGhlIGhpZGRlbiBjbGFzcyBmcm9tIHRoZSBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBjbGFzc05hbWUgb3IgI0lEXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIC0gVGhlIGVsZW1lbnRzIHRvIGZpbmRcblx0ICovXG5cdGluc3RhbmNlLnNob3cgPSBmdW5jdGlvbiBzaG93KGlkZW50aWZpZXIpIHtcblx0XHR0aGlzLnJlbW92ZUNsYXNzKHRoaXMuZ2V0RWxlbWVudHMoaWRlbnRpZmllciksICdoaWRkZW4nKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIEFkZHMgdGhlIGhpZGRlbiBjbGFzcyBvbiB0aGUgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gY2xhc3NOYW1lIG9yICNJRFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciAtIFRoZSBlbGVtZW50cyB0byBmaW5kXG5cdCAqL1xuXHRpbnN0YW5jZS5oaWRlID0gZnVuY3Rpb24gaGlkZShpZGVudGlmaWVyKSB7XG5cdFx0dGhpcy5hZGRDbGFzcyh0aGlzLmdldEVsZW1lbnRzKGlkZW50aWZpZXIpLCAnaGlkZGVuJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBGaW5kcyBhbGwgdGhlIGVsZW1lbnRzIHdpdGggdGhlIGNsYXNzTmFtZSBvciAjSURcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgLSBUaGUgZWxlbWVudHMgdG8gZmluZFxuXHQgKi9cblx0aW5zdGFuY2UuZ2V0RWxlbWVudHMgPSBmdW5jdGlvbiBnZXRFbGVtZW50cyhpZGVudGlmaWVyKSB7XG5cdFx0aWYgKHRoaXMuaXNTdHJpbmcoaWRlbnRpZmllcikpIHtcblx0XHRcdGlmIChpZGVudGlmaWVyLmluZGV4T2YoJyMnKSAhPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkZW50aWZpZXIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaWRlbnRpZmllcik7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGlmIHRoZSB2YXJpYWJsZSBpcyBhIHN0cmluZ1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFyaWFibGUgLSBUaGUgdmFyaWFibGUgdG8gY2hlY2tcblx0ICovXG5cdGluc3RhbmNlLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFyaWFibGUpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGUodmFyaWFibGUsICdbb2JqZWN0IFN0cmluZ10nKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiB0aGUgdmFyaWFibGUgaXMgYSBIVE1MQ29sbGVjdGlvblxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFyaWFibGUgLSBUaGUgdmFyaWFibGUgdG8gY2hlY2tcblx0ICovXG5cdGluc3RhbmNlLmlzSFRNTENvbGxlY3Rpb24gPSBmdW5jdGlvbiBpc0hUTUxDb2xsZWN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlKHZhcmlhYmxlLCAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiB0aGUgdmFyaWFibGUgaXMgdGhlIHR5cGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhcmlhYmxlIC0gVGhlIHZhcmlhYmxlIHRvIGNoZWNrXG5cdCAqL1xuXHRpbnN0YW5jZS5pc1R5cGUgPSBmdW5jdGlvbiBpc1R5cGUodmFyaWFibGUsIHR5cGUpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhcmlhYmxlKSA9PT0gdHlwZTtcblx0fTtcblxuXHRyZXR1cm4gaW5zdGFuY2U7XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4qIEBkZXNjcmlwdGlvbiBFbnRpdHkgc2V0cyBhbGwgZGVmYXVsdCB2YXJpYWJsZXMgdG8gdGhlIG93bmVyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge29iamVjdH0gb3duZXIgLSBUaGUgaW5pdGlhbCByb3dcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaW5pdGlhbCB4IGxvY2F0aW9uXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGluaXRpYWwgeSBsb2NhdGlvblxuKiBAcGFyYW0ge3N0cmluZ30gc3ByaXRlIC0gVGhlIGRpc3BsYXkgc3ByaXRlXG4qIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gVGhlIGluaXRpYWwgeCBvZmZzZXRcbiogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSBUaGUgaW5pdGlhbCB5IG9mZnNldFxuKi9cbnZhciBFbnRpdHkgPSBmdW5jdGlvbiBFbnRpdHkob3duZXIsIHgsIHksIHNwcml0ZSwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuXHR0aGlzLm93bmVyID0gb3duZXI7XG5cdG93bmVyLnggPSB4O1xuXHRvd25lci55ID0geTtcblx0b3duZXIuc3ByaXRlID0gc3ByaXRlIHx8IG51bGw7XG5cdG93bmVyLm9mZnNldFggPSBvZmZzZXRYIHx8IDA7XG5cdG93bmVyLm9mZnNldFkgPSBvZmZzZXRZIHx8IDA7XG5cdG93bmVyLmZsaXBwZWQgPSBmYWxzZTtcblx0b3duZXIuYWxwaGEgPSAxO1xuXHRvd25lci5pc0FsaXZlID0gdHJ1ZTtcblx0b3duZXIuc3BlZWQgPSAwO1xuXHRvd25lci5hbmdsZSA9IDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogUmVzb3VyY2VzLmpzXG4gKiBUaGlzIGlzIHNpbXBsZSBhbiBpbWFnZSBsb2FkaW5nIHV0aWxpdHkuIEl0IGVhc2VzIHRoZSBwcm9jZXNzIG9mIGxvYWRpbmdcbiAqIGltYWdlIGZpbGVzIHNvIHRoYXQgdGhleSBjYW4gYmUgdXNlZCB3aXRoaW4geW91ciBnYW1lLiBJdCBhbHNvIGluY2x1ZGVzXG4gKiBhIHNpbXBsZSBcImNhY2hpbmdcIiBsYXllciBzbyBpdCB3aWxsIHJldXNlIGNhY2hlZCBpbWFnZXMgaWYgeW91IGF0dGVtcHRcbiAqIHRvIGxvYWQgdGhlIHNhbWUgaW1hZ2UgbXVsdGlwbGUgdGltZXMuXG4gKi9cbihmdW5jdGlvbiBSZXNvdXJjZXMoKSB7XG5cdHZhciByZXNvdXJjZUNhY2hlID0ge307XG5cdHZhciBsb2FkaW5nID0gW107XG5cdHZhciByZWFkeUNhbGxiYWNrcyA9IFtdO1xuXG5cdC8qIFRoaXMgaXMgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgaW1hZ2UgbG9hZGluZyBmdW5jdGlvbi4gSXQgYWNjZXB0c1xuXHQgICAqIGFuIGFycmF5IG9mIHN0cmluZ3MgcG9pbnRpbmcgdG8gaW1hZ2UgZmlsZXMgb3IgYSBzdHJpbmcgZm9yIGEgc2luZ2xlXG5cdCAgICogaW1hZ2UuIEl0IHdpbGwgdGhlbiBjYWxsIG91ciBwcml2YXRlIGltYWdlIGxvYWRpbmcgZnVuY3Rpb24gYWNjb3JkaW5nbHkuXG5cdCAgICovXG5cdGZ1bmN0aW9uIGxvYWQodXJsT3JBcnIpIHtcblx0XHRpZiAodXJsT3JBcnIgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0LyogSWYgdGhlIGRldmVsb3BlciBwYXNzZWQgaW4gYW4gYXJyYXkgb2YgaW1hZ2VzXG5cdFx0XHQgICAgICAgKiBsb29wIHRocm91Z2ggZWFjaCB2YWx1ZSBhbmQgY2FsbCBvdXIgaW1hZ2Vcblx0XHRcdCAgICAgICAqIGxvYWRlciBvbiB0aGF0IGltYWdlIGZpbGVcblx0XHRcdCAgICAgICAqL1xuXHRcdFx0dXJsT3JBcnIuZm9yRWFjaChmdW5jdGlvbih1cmwpIHtcblx0XHRcdFx0X2xvYWQodXJsKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBUaGUgZGV2ZWxvcGVyIGRpZCBub3QgcGFzcyBhbiBhcnJheSB0byB0aGlzIGZ1bmN0aW9uLFxuXHRcdFx0ICAgICAgICogYXNzdW1lIHRoZSB2YWx1ZSBpcyBhIHN0cmluZyBhbmQgY2FsbCBvdXIgaW1hZ2UgbG9hZGVyXG5cdFx0XHQgICAgICAgKiBkaXJlY3RseS5cblx0XHRcdCAgICAgICAqL1xuXHRcdFx0X2xvYWQodXJsT3JBcnIpO1xuXHRcdH1cblx0fVxuXG5cdC8qIFRoaXMgaXMgb3VyIHByaXZhdGUgaW1hZ2UgbG9hZGVyIGZ1bmN0aW9uLCBpdCBpc1xuXHQgICAqIGNhbGxlZCBieSB0aGUgcHVibGljIGltYWdlIGxvYWRlciBmdW5jdGlvbi5cblx0ICAgKi9cblx0ZnVuY3Rpb24gX2xvYWQodXJsKSB7XG5cdFx0aWYgKHJlc291cmNlQ2FjaGVbdXJsXSkge1xuXHRcdFx0LyogSWYgdGhpcyBVUkwgaGFzIGJlZW4gcHJldmlvdXNseSBsb2FkZWQgaXQgd2lsbCBleGlzdCB3aXRoaW5cblx0XHRcdCAgICAgICAqIG91ciByZXNvdXJjZUNhY2hlIGFycmF5LiBKdXN0IHJldHVybiB0aGF0IGltYWdlIHJhdGhlclxuXHRcdFx0ICAgICAgICogcmUtbG9hZGluZyB0aGUgaW1hZ2UuXG5cdFx0XHQgICAgICAgKi9cblx0XHRcdHJldHVybiByZXNvdXJjZUNhY2hlW3VybF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIFRoaXMgVVJMIGhhcyBub3QgYmVlbiBwcmV2aW91c2x5IGxvYWRlZCBhbmQgaXMgbm90IHByZXNlbnRcblx0XHRcdCAgICAgICAqIHdpdGhpbiBvdXIgY2FjaGU7IHdlJ2xsIG5lZWQgdG8gbG9hZCB0aGlzIGltYWdlLlxuXHRcdFx0ICAgICAgICovXG5cdFx0XHR2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cdFx0XHRpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8qIE9uY2Ugb3VyIGltYWdlIGhhcyBwcm9wZXJseSBsb2FkZWQsIGFkZCBpdCB0byBvdXIgY2FjaGVcblx0XHRcdFx0ICAgICAgICAgKiBzbyB0aGF0IHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoaXMgaW1hZ2UgaWYgdGhlIGRldmVsb3BlclxuXHRcdFx0XHQgICAgICAgICAqIGF0dGVtcHRzIHRvIGxvYWQgdGhpcyBmaWxlIGluIHRoZSBmdXR1cmUuXG5cdFx0XHRcdCAgICAgICAgICovXG5cdFx0XHRcdHJlc291cmNlQ2FjaGVbdXJsXSA9IGltZztcblxuXHRcdFx0XHQvKiBPbmNlIHRoZSBpbWFnZSBpcyBhY3R1YWxseSBsb2FkZWQgYW5kIHByb3Blcmx5IGNhY2hlZCxcblx0XHRcdFx0ICAgICAgICAgKiBjYWxsIGFsbCBvZiB0aGUgb25SZWFkeSgpIGNhbGxiYWNrcyB3ZSBoYXZlIGRlZmluZWQuXG5cdFx0XHRcdCAgICAgICAgICovXG5cdFx0XHRcdGlmIChpc1JlYWR5KCkpIHtcblx0XHRcdFx0XHRyZWFkeUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHsgZnVuYygpOyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyogU2V0IHRoZSBpbml0aWFsIGNhY2hlIHZhbHVlIHRvIGZhbHNlLCB0aGlzIHdpbGwgY2hhbmdlIHdoZW5cblx0XHRcdCAgICAgICAqIHRoZSBpbWFnZSdzIG9ubG9hZCBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC4gRmluYWxseSwgcG9pbnRcblx0XHRcdCAgICAgICAqIHRoZSBpbWFnZXMgc3JjIGF0dHJpYnV0ZSB0byB0aGUgcGFzc2VkIGluIFVSTC5cblx0XHRcdCAgICAgICAqL1xuXHRcdFx0cmVzb3VyY2VDYWNoZVt1cmxdID0gZmFsc2U7XG5cdFx0XHRpbWcuc3JjID0gdXJsO1xuXHRcdH1cblx0fVxuXG5cdC8qIFRoaXMgaXMgdXNlZCBieSBkZXZlbG9wZXIncyB0byBncmFiIHJlZmVyZW5jZXMgdG8gaW1hZ2VzIHRoZXkga25vd1xuXHQgICAqIGhhdmUgYmVlbiBwcmV2aW91c2x5IGxvYWRlZC4gSWYgYW4gaW1hZ2UgaXMgY2FjaGVkLCB0aGlzIGZ1bmN0aW9uc1xuXHQgICAqIHRoZSBzYW1lIGFzIGNhbGxpbmcgbG9hZCgpIG9uIHRoYXQgVVJMLlxuXHQgICAqL1xuXHRmdW5jdGlvbiBnZXQodXJsKSB7XG5cdFx0cmV0dXJuIHJlc291cmNlQ2FjaGVbdXJsXTtcblx0fVxuXG5cdC8qIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBhbGwgb2YgdGhlIGltYWdlcyB0aGF0IGhhdmUgYmVlbiByZXF1ZXN0ZWRcblx0ICAgKiBmb3IgbG9hZGluZyBoYXZlIGluIGZhY3QgYmVlbiBjb21wbGV0ZWQgbG9hZGVkLlxuXHQgICAqL1xuXHRmdW5jdGlvbiBpc1JlYWR5KCkge1xuXHRcdHZhciByZWFkeSA9IHRydWU7XG5cdFx0Zm9yICh2YXIgayBpbiByZXNvdXJjZUNhY2hlKSB7XG5cdFx0XHRpZiAocmVzb3VyY2VDYWNoZS5oYXNPd25Qcm9wZXJ0eShrKSAmJlxuXHRcdFx0IXJlc291cmNlQ2FjaGVba10pIHtcblx0XHRcdFx0cmVhZHkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlYWR5O1xuXHR9XG5cblx0LyogVGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBhIGZ1bmN0aW9uIHRvIHRoZSBjYWxsYmFjayBzdGFjayB0aGF0IGlzIGNhbGxlZFxuXHQgICAqIHdoZW4gYWxsIHJlcXVlc3RlZCBpbWFnZXMgYXJlIHByb3Blcmx5IGxvYWRlZC5cblx0ICAgKi9cblx0ZnVuY3Rpb24gb25SZWFkeShmdW5jKSB7XG5cdFx0cmVhZHlDYWxsYmFja3MucHVzaChmdW5jKTtcblx0fVxuXG5cdC8qIFRoaXMgb2JqZWN0IGRlZmluZXMgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgZnVuY3Rpb25zIGF2YWlsYWJsZSB0b1xuXHQgICAqIGRldmVsb3BlcnMgYnkgY3JlYXRpbmcgYSBnbG9iYWwgUmVzb3VyY2VzIG9iamVjdC5cblx0ICAgKi9cblx0d2luZG93LlJlc291cmNlcyA9IHtcblx0XHRsb2FkOiBsb2FkLFxuXHRcdGdldDogZ2V0LFxuXHRcdG9uUmVhZHk6IG9uUmVhZHksXG5cdFx0aXNSZWFkeTogaXNSZWFkeVxuXHR9O1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQGRlc2NyaXB0aW9uIENvbGxpc2lvbiBTaW5nbGV0b24gdXNlZCBmb3IgY2hlY2tpbmcgY29sbGlzaW9uIGJldHdlZW4gdHdvIHNlbnNvcnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sbGlzaW9uID0gKGZ1bmN0aW9uIFByb3RvdHlwZSgpIHtcblx0dmFyIGluc3RhbmNlID0gZnVuY3Rpb24gaW5zdGFuY2UoKSB7fTtcblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBVc2VzIGJveCBjb2xsaXNpb24gdG8gY2hlY2sgaWYgdHdvIHNlbnNvcnMgYXJlIHRvdWNoaW5nXG5cdCAqIEBwYXJhbSB7U2Vub3J9IHNlbnNvckEgLSBCb3VuZGluZyByZWN0IEFcblx0ICogQHBhcmFtIHtTZW5vcn0gc2Vuc29yQiAtIEJvdW5kaW5nIHJlY3QgQlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYmFzZWQgb24gc2Vuc29yIG92ZXJsYXBcblx0ICovXG5cdGluc3RhbmNlLmlzQ29sbGlkaW5nID0gZnVuY3Rpb24gaXNDb2xsaWRpbmcoc2Vuc29yQSwgc2Vuc29yQikge1xuXHRcdHJldHVybiAoc2Vuc29yQS54IDwgc2Vuc29yQi54ICsgc2Vuc29yQi53aWR0aCAmJlxuXHRcdFx0c2Vuc29yQS54ICsgc2Vuc29yQi53aWR0aCA+IHNlbnNvckIueCAmJlxuXHRcdFx0c2Vuc29yQS55IDwgc2Vuc29yQi55ICsgc2Vuc29yQi5oZWlnaHQgJiZcblx0XHRcdHNlbnNvckEuaGVpZ2h0ICsgc2Vuc29yQS55ID4gc2Vuc29yQi55KTtcblx0fTtcblx0cmV0dXJuIGluc3RhbmNlO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEVuZ2luZS5qc1xuICogVGhpcyBmaWxlIHByb3ZpZGVzIHRoZSBnYW1lIGxvb3AgZnVuY3Rpb25hbGl0eSAodXBkYXRlIGVudGl0aWVzIGFuZCByZW5kZXIpLFxuICogZHJhd3MgdGhlIGluaXRpYWwgZ2FtZSBib2FyZCBvbiB0aGUgc2NyZWVuLCBhbmQgdGhlbiBjYWxscyB0aGUgdXBkYXRlIGFuZFxuICogcmVuZGVyIG1ldGhvZHMgb24geW91ciBwbGF5ZXIgYW5kIGVuZW15IG9iamVjdHMgKGRlZmluZWQgaW4geW91ciBhcHAuanMpLlxuICpcbiAqIEEgZ2FtZSBlbmdpbmUgd29ya3MgYnkgZHJhd2luZyB0aGUgZW50aXJlIGdhbWUgc2NyZWVuIG92ZXIgYW5kIG92ZXIsIGtpbmQgb2ZcbiAqIGxpa2UgYSBmbGlwYm9vayB5b3UgbWF5IGhhdmUgY3JlYXRlZCBhcyBhIGtpZC4gV2hlbiB5b3VyIHBsYXllciBtb3ZlcyBhY3Jvc3NcbiAqIHRoZSBzY3JlZW4sIGl0IG1heSBsb29rIGxpa2UganVzdCB0aGF0IGltYWdlL2NoYXJhY3RlciBpcyBtb3Zpbmcgb3IgYmVpbmdcbiAqIGRyYXduIGJ1dCB0aGF0IGlzIG5vdCB0aGUgY2FzZS4gV2hhdCdzIHJlYWxseSBoYXBwZW5pbmcgaXMgdGhlIGVudGlyZSBcInNjZW5lXCJcbiAqIGlzIGJlaW5nIGRyYXduIG92ZXIgYW5kIG92ZXIsIHByZXNlbnRpbmcgdGhlIGlsbHVzaW9uIG9mIGFuaW1hdGlvbi5cbiAqXG4gKiBUaGlzIGVuZ2luZSBpcyBhdmFpbGFibGUgZ2xvYmFsbHkgdmlhIHRoZSBFbmdpbmUgdmFyaWFibGUgYW5kIGl0IGFsc28gbWFrZXNcbiAqIHRoZSBjYW52YXMnIGNvbnRleHQgKGN0eCkgb2JqZWN0IGdsb2JhbGx5IGF2YWlsYWJsZSB0byBtYWtlIHdyaXRpbmcgYXBwLmpzXG4gKiBhIGxpdHRsZSBzaW1wbGVyIHRvIHdvcmsgd2l0aC5cbiAqL1xuXG52YXIgRW5naW5lID0gKGZ1bmN0aW9uIEVuZ2luZShnbG9iYWwpIHtcblx0LyogUHJlZGVmaW5lIHRoZSB2YXJpYWJsZXMgd2UnbGwgYmUgdXNpbmcgd2l0aGluIHRoaXMgc2NvcGUsXG5cdCAgICogY3JlYXRlIHRoZSBjYW52YXMgZWxlbWVudCwgZ3JhYiB0aGUgMkQgY29udGV4dCBmb3IgdGhhdCBjYW52YXNcblx0ICAgKiBzZXQgdGhlIGNhbnZhcyBlbGVtZW50cyBoZWlnaHQvd2lkdGggYW5kIGFkZCBpdCB0byB0aGUgRE9NLlxuXHQgICAqL1xuXHR2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50LFxuXHR3aW4gPSBnbG9iYWwud2luZG93LFxuXHRjYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXG5cdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuXHRsYXN0VGltZSxcblx0cnVubmluZyA9IGZhbHNlLFxuXHRpbnN0YW5jZSA9IGZ1bmN0aW9uIGluc3RhbmNlKCkge307XG5cblx0aW5zdGFuY2UuZW50aXRpZXMgPSBbXTtcblx0aW5zdGFuY2Uud2lkdGggPSBjYW52YXMud2lkdGggPSA1MDU7XG5cdGluc3RhbmNlLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSA2MDY7XG5cdGNhbnZhcy5jbGFzc05hbWUgKz0gJyBjYW52YXMtZ2FtZSc7XG5cdGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZXZlbCcpWzBdLmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cblx0LyogVGhpcyBpcyBjYWxsZWQgYnkgdGhlIHVwZGF0ZSBmdW5jdGlvbiAgYW5kIGxvb3BzIHRocm91Z2ggYWxsIG9mIHRoZVxuXHQgICAqIG9iamVjdHMgd2l0aGluIHlvdXIgaW5zdGFuY2UuZW50aXRpZXMgYXJyYXkgYXMgZGVmaW5lZCBpbiBhcHAuanMgYW5kIGNhbGxzXG5cdCAgICogdGhlaXIgdXBkYXRlKCkgbWV0aG9kcy4gSXQgd2lsbCB0aGVuIGNhbGwgdGhlIHVwZGF0ZSBmdW5jdGlvbiBmb3IgeW91clxuXHQgICAqIHBsYXllciBvYmplY3QuIFRoZXNlIHVwZGF0ZSBtZXRob2RzIHNob3VsZCBmb2N1cyBwdXJlbHkgb24gdXBkYXRpbmdcblx0ICAgKiB0aGUgZGF0YS9wcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gIHRoZSBvYmplY3QuIERvIHlvdXIgZHJhd2luZyBpbiB5b3VyXG5cdCAgICogcmVuZGVyIG1ldGhvZHMuXG5cdCAgICovXG5cdGZ1bmN0aW9uIHVwZGF0ZUVudGl0aWVzKGR0KSB7XG5cdFx0aW5zdGFuY2UuZW50aXRpZXMuZm9yRWFjaChmdW5jdGlvbiBFYWNoRW5lbXkoZW5lbXkpIHtcblx0XHRcdGVuZW15LnVwZGF0ZShkdCk7XG5cdFx0fSk7XG5cdFx0cGxheWVyLnVwZGF0ZShkdCk7XG5cdH1cblxuXHQvKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBtYWluIChvdXIgZ2FtZSBsb29wKSBhbmQgaXRzZWxmIGNhbGxzIGFsbFxuXHQgICAqIG9mIHRoZSBmdW5jdGlvbnMgd2hpY2ggbWF5IG5lZWQgdG8gdXBkYXRlIGVudGl0eSdzIGRhdGEuIEJhc2VkIG9uIGhvd1xuXHQgICAqIHlvdSBpbXBsZW1lbnQgeW91ciBjb2xsaXNpb24gZGV0ZWN0aW9uICh3aGVuIHR3byBlbnRpdGllcyBvY2N1cHkgdGhlXG5cdCAgICogc2FtZSBzcGFjZSwgZm9yIGluc3RhbmNlIHdoZW4geW91ciBjaGFyYWN0ZXIgc2hvdWxkIGRpZSksIHlvdSBtYXkgZmluZFxuXHQgICAqIHRoZSBuZWVkIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGZ1bmN0aW9uIGNhbGwgaGVyZS4gRm9yIG5vdywgd2UndmUgbGVmdFxuXHQgICAqIGl0IGNvbW1lbnRlZCBvdXQgLSB5b3UgbWF5IG9yIG1heSBub3Qgd2FudCB0byBpbXBsZW1lbnQgdGhpc1xuXHQgICAqIGZ1bmN0aW9uYWxpdHkgdGhpcyB3YXkgKHlvdSBjb3VsZCBqdXN0IGltcGxlbWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uXG5cdCAgICogb24gdGhlIGVudGl0aWVzIHRoZW1zZWx2ZXMgd2l0aGluIHlvdXIgYXBwLmpzIGZpbGUpLlxuXHQgICAqL1xuXHRmdW5jdGlvbiB1cGRhdGUoZHQpIHtcblx0XHR1cGRhdGVFbnRpdGllcyhkdCk7XG5cdFx0Ly8gY2hlY2tDb2xsaXNpb25zKCk7XG5cdH1cblxuXHQvKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGFuZCBpcyBjYWxsZWQgb24gZWFjaCBnYW1lXG5cdCAgICogdGljay4gSXQncyBwdXJwb3NlIGlzIHRvIHRoZW4gY2FsbCB0aGUgcmVuZGVyIGZ1bmN0aW9ucyB5b3UgaGF2ZSBkZWZpbmVkXG5cdCAgICogb24geW91ciBlbmVteSBhbmQgcGxheWVyIGVudGl0aWVzIHdpdGhpbiBhcHAuanNcblx0ICAgKi9cblx0ZnVuY3Rpb24gcmVuZGVyRW50aXRpZXMoKSB7XG5cdFx0LyogTG9vcCB0aHJvdWdoIGFsbCBvZiB0aGUgb2JqZWN0cyB3aXRoaW4gdGhlIGluc3RhbmNlLmVudGl0aWVzIGFycmF5IGFuZCBjYWxsXG5cdFx0ICAgICAqIHRoZSByZW5kZXIgZnVuY3Rpb24geW91IGhhdmUgZGVmaW5lZC5cblx0XHQgICAgICovXG5cdFx0dmFyIGk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGluc3RhbmNlLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpbnN0YW5jZS5lbnRpdGllc1tpXS5yZW5kZXIoY3R4KTtcblx0XHR9XG5cblx0XHRwbGF5ZXIucmVuZGVyKGN0eCk7XG5cdH1cblxuXHQvKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxseSBkcmF3cyB0aGUgXCJnYW1lIGxldmVsXCIsIGl0IHdpbGwgdGhlbiBjYWxsXG5cdCAgICogdGhlIHJlbmRlckVudGl0aWVzIGZ1bmN0aW9uLiBSZW1lbWJlciwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnlcblx0ICAgKiBnYW1lIHRpY2sgKG9yIGxvb3Agb2YgdGhlIGdhbWUgZW5naW5lKSBiZWNhdXNlIHRoYXQncyBob3cgZ2FtZXMgd29yayAtXG5cdCAgICogdGhleSBhcmUgZmxpcGJvb2tzIGNyZWF0aW5nIHRoZSBpbGx1c2lvbiBvZiBhbmltYXRpb24gYnV0IGluIHJlYWxpdHlcblx0ICAgKiB0aGV5IGFyZSBqdXN0IGRyYXdpbmcgdGhlIGVudGlyZSBzY3JlZW4gb3ZlciBhbmQgb3Zlci5cblx0ICAgKi9cblx0ZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRcdC8qIFRoaXMgYXJyYXkgaG9sZHMgdGhlIHJlbGF0aXZlIFVSTCB0byB0aGUgaW1hZ2UgdXNlZFxuXHRcdCAgICAgKiBmb3IgdGhhdCBwYXJ0aWN1bGFyIHJvdyBvZiB0aGUgZ2FtZSBsZXZlbC5cblx0XHQgICAgICovXG5cdFx0dmFyIHJvd0ltYWdlcyA9IFtcblx0XHQnaW1hZ2VzL3dhdGVyLWJsb2NrLnBuZycsICAgLy8gVG9wIHJvdyBpcyB3YXRlclxuXHRcdCdpbWFnZXMvc3RvbmUtYmxvY2sucG5nJywgICAvLyBSb3cgMSBvZiAzIG9mIHN0b25lXG5cdFx0J2ltYWdlcy9zdG9uZS1ibG9jay5wbmcnLCAgIC8vIFJvdyAyIG9mIDMgb2Ygc3RvbmVcblx0XHQnaW1hZ2VzL3N0b25lLWJsb2NrLnBuZycsICAgLy8gUm93IDMgb2YgMyBvZiBzdG9uZVxuXHRcdCdpbWFnZXMvZ3Jhc3MtYmxvY2sucG5nJywgICAvLyBSb3cgMSBvZiAyIG9mIGdyYXNzXG5cdFx0J2ltYWdlcy9ncmFzcy1ibG9jay5wbmcnICAgIC8vIFJvdyAyIG9mIDIgb2YgZ3Jhc3Ncblx0XHRdLFxuXHRcdG51bVJvd3MgPSA2LFxuXHRcdG51bUNvbHMgPSA1LFxuXHRcdHJvdywgY29sO1xuXG5cdFx0Ly8gIENsZWFyIHRoZSBlbnRpcmUgY2FudmFzXG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0LyogTG9vcCB0aHJvdWdoIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyB3ZSd2ZSBkZWZpbmVkIGFib3ZlXG5cdFx0ICAgICAqIGFuZCwgdXNpbmcgdGhlIHJvd0ltYWdlcyBhcnJheSwgZHJhdyB0aGUgY29ycmVjdCBpbWFnZSBmb3IgdGhhdFxuXHRcdCAgICAgKiBwb3J0aW9uIG9mIHRoZSBcImdyaWRcIlxuXHRcdCAgICAgKi9cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IG51bVJvd3M7IHJvdysrKSB7XG5cdFx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IG51bUNvbHM7IGNvbCsrKSB7XG5cdFx0XHRcdC8qIFRoZSBkcmF3SW1hZ2UgZnVuY3Rpb24gb2YgdGhlIGNhbnZhcycgY29udGV4dCBlbGVtZW50XG5cdFx0XHRcdCAgICAgICAgICogcmVxdWlyZXMgMyBwYXJhbWV0ZXJzOiB0aGUgaW1hZ2UgdG8gZHJhdywgdGhlIHggY29vcmRpbmF0ZVxuXHRcdFx0XHQgICAgICAgICAqIHRvIHN0YXJ0IGRyYXdpbmcgYW5kIHRoZSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgZHJhd2luZy5cblx0XHRcdFx0ICAgICAgICAgKiBXZSdyZSB1c2luZyBvdXIgUmVzb3VyY2VzIGhlbHBlcnMgdG8gcmVmZXIgdG8gb3VyIGltYWdlc1xuXHRcdFx0XHQgICAgICAgICAqIHNvIHRoYXQgd2UgZ2V0IHRoZSBiZW5lZml0cyBvZiBjYWNoaW5nIHRoZXNlIGltYWdlcywgc2luY2Vcblx0XHRcdFx0ICAgICAgICAgKiB3ZSdyZSB1c2luZyB0aGVtIG92ZXIgYW5kIG92ZXIuXG5cdFx0XHRcdCAgICAgICAgICovXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoUmVzb3VyY2VzLmdldChyb3dJbWFnZXNbcm93XSksIGNvbCAqIDEwMSwgcm93ICogODMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJlbmRlckVudGl0aWVzKCk7XG5cdH1cblx0XG5cdC8qIFRoaXMgZnVuY3Rpb24gc2VydmVzIGFzIHRoZSBraWNrb2ZmIHBvaW50IGZvciB0aGUgZ2FtZSBsb29wIGl0c2VsZlxuXHQgICAqIGFuZCBoYW5kbGVzIHByb3Blcmx5IGNhbGxpbmcgdGhlIHVwZGF0ZSBhbmQgcmVuZGVyIG1ldGhvZHMuXG5cdCAgICovXG5cdGZ1bmN0aW9uIG1haW4oKSB7XG5cdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdC8qIEdldCBvdXIgdGltZSBkZWx0YSBpbmZvcm1hdGlvbiB3aGljaCBpcyByZXF1aXJlZCBpZiB5b3VyIGdhbWVcblx0XHRcdCAgICAgICAqIHJlcXVpcmVzIHNtb290aCBhbmltYXRpb24uIEJlY2F1c2UgZXZlcnlvbmUncyBjb21wdXRlciBwcm9jZXNzZXNcblx0XHRcdCAgICAgICAqIGluc3RydWN0aW9ucyBhdCBkaWZmZXJlbnQgc3BlZWRzIHdlIG5lZWQgYSBjb25zdGFudCB2YWx1ZSB0aGF0XG5cdFx0XHQgICAgICAgKiB3b3VsZCBiZSB0aGUgc2FtZSBmb3IgZXZlcnlvbmUgKHJlZ2FyZGxlc3Mgb2YgaG93IGZhc3QgdGhlaXJcblx0XHRcdCAgICAgICAqIGNvbXB1dGVyIGlzKSAtIGh1cnJheSB0aW1lIVxuXHRcdFx0ICAgICAgICovXG5cdFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcblx0XHRcdGR0ID0gKG5vdyAtIGxhc3RUaW1lKSAvIDEwMDAuMDtcblxuXHRcdFx0LyogQ2FsbCBvdXIgdXBkYXRlL3JlbmRlciBmdW5jdGlvbnMsIHBhc3MgYWxvbmcgdGhlIHRpbWUgZGVsdGEgdG9cblx0XHRcdCAqIG91ciB1cGRhdGUgZnVuY3Rpb24gc2luY2UgaXQgbWF5IGJlIHVzZWQgZm9yIHNtb290aCBhbmltYXRpb24uXG5cdFx0XHQgKi9cblx0XHRcdHVwZGF0ZShkdCk7XG5cdFx0XHRyZW5kZXIoKTtcblxuXHRcdFx0LyogU2V0IG91ciBsYXN0VGltZSB2YXJpYWJsZSB3aGljaCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgdGltZSBkZWx0YVxuXHRcdFx0ICogZm9yIHRoZSBuZXh0IHRpbWUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXG5cdFx0XHQgKi9cblx0XHRcdGxhc3RUaW1lID0gbm93O1xuXG5cdFx0XHQvKiBVc2UgdGhlIGJyb3dzZXIncyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnVuY3Rpb24gdG8gY2FsbCB0aGlzXG5cdFx0XHQgKiBmdW5jdGlvbiBhZ2FpbiBhcyBzb29uIGFzIHRoZSBicm93c2VyIGlzIGFibGUgdG8gZHJhdyBhbm90aGVyIGZyYW1lLlxuXHRcdFx0ICovXG5cdFx0XHR3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1haW4pO1xuXHRcdH1cblx0fVxuXG5cdC8qIFRoaXMgZnVuY3Rpb24gZG9lcyBzb21lIGluaXRpYWwgc2V0dXAgdGhhdCBzaG91bGQgb25seSBvY2N1ciBvbmNlLFxuXHQgICAqIHBhcnRpY3VsYXJseSBzZXR0aW5nIHRoZSBsYXN0VGltZSB2YXJpYWJsZSB0aGF0IGlzIHJlcXVpcmVkIGZvciB0aGVcblx0ICAgKiBnYW1lIGxvb3AuXG5cdCAgICovXG5cdGZ1bmN0aW9uIGluaXQoKSB7XG5cdFx0aW5zdGFuY2UucmVzZXQoKTtcblx0XHRydW5uaW5nID0gdHJ1ZTtcblx0XHRsYXN0VGltZSA9IERhdGUubm93KCk7XG5cdFx0bWFpbigpO1xuXHR9XG5cblx0LyogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdGhpbmcgYnV0IGl0IGNvdWxkIGhhdmUgYmVlbiBhIGdvb2QgcGxhY2UgdG9cblx0ICAgKiBoYW5kbGUgZ2FtZSByZXNldCBzdGF0ZXMgLSBtYXliZSBhIG5ldyBnYW1lIG1lbnUgb3IgYSBnYW1lIG92ZXIgc2NyZWVuXG5cdCAgICogdGhvc2Ugc29ydHMgb2YgdGhpbmdzLiBJdCdzIG9ubHkgY2FsbGVkIG9uY2UgYnkgdGhlIGluaXQoKSBtZXRob2QuXG5cdCAgICovXG5cdGluc3RhbmNlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG5cdFx0cnVubmluZyA9IGZhbHNlO1xuXHR9O1xuXG5cdGluc3RhbmNlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoKSB7XG5cdFx0cnVubmluZyA9IGZhbHNlO1xuXHR9O1xuXG5cdGluc3RhbmNlLnByZWxvYWQgPSBmdW5jdGlvbiBwcmVsb2FkKCkge1xuXHRcdC8qIEdvIGFoZWFkIGFuZCBsb2FkIGFsbCBvZiB0aGUgaW1hZ2VzIHdlIGtub3cgd2UncmUgZ29pbmcgdG8gbmVlZCB0b1xuXHRcdCAgICAgKiBkcmF3IG91ciBnYW1lIGxldmVsLiBUaGVuIHNldCBpbml0IGFzIHRoZSBjYWxsYmFjayBtZXRob2QsIHNvIHRoYXQgd2hlblxuXHRcdCAgICAgKiBhbGwgb2YgdGhlc2UgaW1hZ2VzIGFyZSBwcm9wZXJseSBsb2FkZWQgb3VyIGdhbWUgd2lsbCBzdGFydC5cblx0XHQgICAgICovXG5cblx0XHRmdW5jdGlvbiBsb2NhdGlvbnMoZm9sZGVyLCBmb3JtYXQpIHtcblx0XHRcdHZhciByZXNvdXJjZXMgPSBbXG5cdFx0XHQnY2hhci1ib3knLFxuXHRcdFx0J2NoYXItY2F0LWdpcmwnLFxuXHRcdFx0J2NoYXItaG9ybi1naXJsJyxcblx0XHRcdCdjaGFyLXBpbmstZ2lybCcsXG5cdFx0XHQnY2hhci1wcmluY2Vzcy1naXJsJyxcblx0XHRcdCdlbmVteS1idWcnLFxuXHRcdFx0J0dlbSBCbHVlJyxcblx0XHRcdCdHZW0gR3JlZW4nLFxuXHRcdFx0J0dlbSBPcmFuZ2UnLFxuXHRcdFx0J2dyYXNzLWJsb2NrJyxcblx0XHRcdCdIZWFydCcsXG5cdFx0XHQnS2V5Jyxcblx0XHRcdCdSb2NrJyxcblx0XHRcdCdTZWxlY3RvcicsXG5cdFx0XHQnU3RhcicsXG5cdFx0XHQnc3RvbmUtYmxvY2snLFxuXHRcdFx0J3dhdGVyLWJsb2NrJ1xuXHRcdFx0XTtcblx0XHRcdHJldHVybiByZXNvdXJjZXMubWFwKGZ1bmN0aW9uIHJlc291cmNlTWFwKGVsKSB7XG5cdFx0XHRcdHJldHVybiBmb2xkZXIgKyBlbCArICcuJyArIGZvcm1hdDtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRSZXNvdXJjZXMubG9hZChsb2NhdGlvbnMoJ2ltYWdlcy8nLCAncG5nJykpO1xuXG5cdFx0aWYgKFJlc291cmNlcy5pc1JlYWR5KCkpIHtcblx0XHRcdGluaXQoKTtcblx0XHR9ZWxzZSB7XG5cdFx0XHRSZXNvdXJjZXMub25SZWFkeShpbml0KTtcblx0XHR9XG5cdH07XG5cblx0LyogQXNzaWduIHRoZSBjYW52YXMnIGNvbnRleHQgb2JqZWN0IHRvIHRoZSBnbG9iYWwgdmFyaWFibGUgKHRoZSB3aW5kb3dcblx0ICAgKiBvYmplY3Qgd2hlbiBydW4gaW4gYSBicm93c2VyKSBzbyB0aGF0IGRldmVsb3BlcidzIGNhbiB1c2UgaXQgbW9yZSBlYXNpbHlcblx0ICAgKiBmcm9tIHdpdGhpbiB0aGVpciBhcHAuanMgZmlsZXMuXG5cdCAgICovXG5cdGdsb2JhbC5jdHggPSBjdHg7XG5cblx0cmV0dXJuIGluc3RhbmNlO1xufSkodGhpcyk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiogQGRlc2NyaXB0aW9uIE1vZGVsIFNpbmdsZXRvbiB1c2VkIGZvciBzdG9yaW5nIHN0YXRlIGRhdGFcbiogQGNvbnN0cnVjdG9yXG4qL1xudmFyIE1vZGVsID0gKGZ1bmN0aW9uIE1vZGVsKCkge1xuXHR2YXIgZGF0YSA9IHt9O1xuXHR2YXIgaW5zdGFuY2UgPSBmdW5jdGlvbiBpbnN0YW5jZSgpIHt9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gU2V0cyBhIHZhbHVlIHRvIGEga2V5XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgcHJvcGVydHkgdG8gc3RvcmUgdGhlIHZhbHVlIHVuZGVyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUga2V5XG5cdCAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgb2YgdGhlIGtleVxuXHQgKi9cblx0aW5zdGFuY2Uuc2V0ID0gZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcblx0XHRkYXRhW2tleV0gPSB2YWx1ZTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSB2YWx1ZSBzZXQgdG8gdGhlIGtleVxuXHQgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBrZXlcblx0ICovXG5cdGluc3RhbmNlLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcblx0XHRyZXR1cm4gZGF0YVtrZXldO1xuXHR9O1xuXG5cdHJldHVybiBpbnN0YW5jZTtcbn0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiogQGRlc2NyaXB0aW9uIEEgVGltZXIgY2xhc3MgdGhhdCB1cGRhdGVzIG1hbnVhbGx5IHVzaW5nIHdpdGggZGVsdGEgdGltZVxuKiBAY29uc3RydWN0b3JcbiovXG52YXIgVGltZXIgPSBmdW5jdGlvbiBUaW1lcihpbnRlcnZhbHMsIGRlbGF5KSB7XG5cdHRoaXMuaW50ZXJ2YWxzID0gaW50ZXJ2YWxzO1xuXHR0aGlzLmRlbGF5ID0gZGVsYXk7XG5cdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHR0aGlzLmxpc3RlbmVycyA9IHt9O1xuXHR0aGlzLnRpbWUgPSAwO1xuXHR0aGlzLmxhcHMgPSAwO1xufTtcblxuKGZ1bmN0aW9uIFByb3RvdHlwZSgpIHtcblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXNldHMgdGhlIHRpbWVyIGFuZCBmbGFncyBpdCBhcyBydW5uaW5nXG5cdCAqL1xuXHR0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHR0aGlzLnRpbWUgPSB0aGlzLmRlbGF5O1xuXHRcdHRoaXMubGFwcyA9IHRoaXMuaW50ZXJ2YWxzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gVXNlcyB0aGUgZGVsdGEgdGltZSB0byBtYW51YWxseSB1cGRhdGUgdGhlIHRpbWVyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSAtIFRpbWUgc2luY2UgbGFzdCB1cGRhdGVcblx0ICovXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGRlbHRhKSB7XG5cdFx0aWYgKHRoaXMucnVubmluZykge1xuXHRcdFx0dGhpcy50aW1lID0gTWF0aC5tYXgoMCwgdGhpcy50aW1lIC0gZGVsdGEpO1xuXHRcdFx0aWYgKHRoaXMudGltZSA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLmxhcHMgLT0gMTtcblx0XHRcdFx0aWYgKHRoaXMubGFwcyA8PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaCgnQ09NUExFVEUnKTtcblx0XHRcdFx0fWVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudGltZSA9IHRoaXMuZGVsYXk7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaCgnVVBEQVRFJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBBZGRzIGEgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGxpc3RlbiBmb3Jcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cblx0ICovXG5cdHRoaXMub24gPSBmdW5jdGlvbiBvbihldmVudCwgbGlzdGVuZXIpIHtcblx0XHRpZiAoIXRoaXMubGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuXHRcdFx0dGhpcy5saXN0ZW5lcnNbZXZlbnRdID0gW107XG5cdFx0fVxuXHRcdHRoaXMubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIEF0dGVtcHRzIHRvIGludm9rZSBhIGNhbGxiYWNrIG1ldGhvZCBmb3IgdGhlIGdpdmVuIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCB0byBkaXNwYXRjaFxuXHQgKi9cblx0dGhpcy5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKGV2ZW50KSB7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIGxpc3Q7XG5cdFx0aWYgKHRoaXMubGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuXHRcdFx0bGlzdCA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxpc3RbaV0odGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSkuY2FsbChUaW1lci5wcm90b3R5cGUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4qIEBkZXNjcmlwdGlvbiBHcmlkIFNpbmdsZXRvbiB1c2VkIGZvciBwb3NpdGlvbmluZyB0aGluZ3Mgb24gYSBHcmlkXG4qIEBjb25zdHJ1Y3RvclxuKi9cbnZhciBHcmlkID0gKGZ1bmN0aW9uIEdyaWQoKSB7XG5cdHZhciBpbnN0YW5jZSA9IGZ1bmN0aW9uIGluc3RhbmNlKCkge307XG5cblx0aW5zdGFuY2UuY2VsbFdpZHRoID0gMTAxO1xuXHRpbnN0YW5jZS5jZWxsSGVpZ2h0ID0gODM7XG5cdGluc3RhbmNlLmNvbHVtbnMgPSA1O1xuXHRpbnN0YW5jZS5yb3dzID0gNjtcblx0aW5zdGFuY2Uub2Zmc2V0WSA9IDUwO1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gRGV0ZXJtaW5lcyB0aGUgeCBsb2NhdGlvbiBiYXNlZCBvbiB0aGUgY29sdW1uXG5cdCAqIEBwYXJhbSB7aW50fSBjb2x1bW4gLSBUaGUgY29sdW1uXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzY3JlZW4geCBwb3NpdGlvblxuXHQgKi9cblx0aW5zdGFuY2UuZ2V0WEZyb21Db2x1bW4gPSBmdW5jdGlvbiBnZXRYRnJvbUNvbHVtbihjb2x1bW4pIHtcblx0XHR2YXIgY29sID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY29sdW1uLCBpbnN0YW5jZS5jb2x1bW5zIC0gMSkpO1xuXHRcdHJldHVybiBjb2wgKiBpbnN0YW5jZS5jZWxsV2lkdGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBEZXRlcm1pbmVzIHRoZSB5IGxvY2F0aW9uIGJhc2VkIG9uIHRoZSByb3dcblx0ICogQHBhcmFtIHtpbnR9IHJvdyAtIFRoZSByb3dcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHNjcmVlbiB5IHBvc2l0aW9uXG5cdCAqL1xuXHRpbnN0YW5jZS5nZXRZRnJvbVJvdyA9IGZ1bmN0aW9uIGdldFlGcm9tUm93KHJvdykge1xuXHRcdHJvdyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJvdywgaW5zdGFuY2Uucm93cyAtIDEpKTtcblx0XHRyZXR1cm4gaW5zdGFuY2Uub2Zmc2V0WSArIHJvdyAqIGluc3RhbmNlLmNlbGxIZWlnaHQ7XG5cdH07XG5cblx0cmV0dXJuIGluc3RhbmNlO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gSGFuZGxlcyBsZXZlbCBjcmVhdGlvblxuKiBAY29uc3RydWN0b3JcbiovXG52YXIgTGV2ZWwgPSBmdW5jdGlvbiBMZXZlbCgpIHtcblx0dGhpcy5yZXNldCgpO1xufTtcblxuKGZ1bmN0aW9uIFByb3RvdHlwZSgpIHtcblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXNldCdzIGxldmVsIHZhcmlhYmxlcyB0byBvcmlnaW5hbCB2YWx1ZXNcblx0ICovXG5cdHRoaXMucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcblx0XHR0aGlzLmxldmVsID0gTW9kZWwuc2V0KCdsZXZlbCcsIDApO1xuXHRcdHRoaXMubGFzdExldmVsID0gNztcblx0XHRNb2RlbC5zZXQoJ2xldmVsX3RvdGFsX3RpbWUnLCAxNSk7XG5cdFx0TW9kZWwuc2V0KCdsZXZlbF9jb21wbGV0ZScsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIEFkdmFuY2VzIHRoZSBjdXJyZW50IGxldmVsIGJ5IG9uZVxuXHQgKi9cblx0dGhpcy5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcblx0XHR0aGlzLmxldmVsID0gTW9kZWwuc2V0KCdsZXZlbCcsIHRoaXMubGV2ZWwgKyAxKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYWxsIHRoZSBlbnRpdGllcyBmb3IgdGhlIGN1cnJlbnQgbGV2ZWxcblx0ICovXG5cdHRoaXMuYWRkRW50aXRpZXMgPSBmdW5jdGlvbiBhZGRFbnRpdGllcygpIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMubGV2ZWxEYXRhKCk7XG5cdFx0dmFyIGk7XG5cdFx0RW5naW5lLmVudGl0aWVzID0gW107XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGRhdGFbaV0uaGFzT3duUHJvcGVydHkoJ3QnKSkge1xuXHRcdFx0XHRpZiAoZGF0YVtpXS50ID09PSAna2V5Jykge1xuXHRcdFx0XHRcdEVuZ2luZS5lbnRpdGllcy5wdXNoKG5ldyBLZXkoZGF0YVtpXS5yLCBkYXRhW2ldLmMpKTtcblx0XHRcdFx0fWVsc2UgaWYgKGRhdGFbaV0udCA9PT0gJ3dhdGVyJykge1xuXHRcdFx0XHRcdEVuZ2luZS5lbnRpdGllcy5wdXNoKG5ldyBXYXRlcihkYXRhW2ldLnIsIGRhdGFbaV0uYykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZSB7XG5cdFx0XHRcdEVuZ2luZS5lbnRpdGllcy5wdXNoKG5ldyBFbmVteShkYXRhW2ldLnIsIGRhdGFbaV0uYywgZGF0YVtpXS5zKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgSlNPTiBlbnRpdGllcyBmb3IgdGhlIGdpdmVuIGxldmVsXG5cdCAqIEByZXR1cm5zIHthcnJheX1cblx0ICovXG5cdHRoaXMubGV2ZWxEYXRhID0gZnVuY3Rpb24gbGV2ZWxEYXRhKCkge1xuXHRcdC8vICBGb3JtYXR0ZWQgc28gaXQncyBlYXNpZXIgdG8gc2VlIHRoZSBsZXZlbHMgKG5vdCBmb2xsb3dpbmcgVWRhY2l0eSBKUyBzdGFuZGFyZHMpXG5cdFx0Ly8gIGpzY3M6ZGlzYWJsZVxuXHRcdGlmICh0aGlzLmxldmVsID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0e3I6IDAsIGM6IDAsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMSwgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiAyLCB0OiAna2V5J30sIHtyOiAwLCBjOiAzLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDQsIHQ6ICd3YXRlcid9XG5cdFx0XHRdO1xuXHRcdH1lbHNlIGlmICh0aGlzLmxldmVsID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0e3I6IDMsIGM6IDAsIHM6IDIwMH0sIHtyOiAzLCBjOiAyLCBzOiAyMDB9LCB7cjogMywgYzogNCwgczogMjAwfSxcblx0XHRcdHtyOiAwLCBjOiAwLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDEsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMiwgdDogJ2tleSd9LCB7cjogMCwgYzogMywgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiA0LCB0OiAnd2F0ZXInfVxuXHRcdFx0XTtcblx0XHR9ZWxzZSBpZiAodGhpcy5sZXZlbCA9PT0gMikge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdHtyOiAxLCBjOiAwLCBzOiAtMTAwfSwge3I6IDEsIGM6IDEsIHM6IC0xMDB9LCB7cjogMSwgYzogMywgczogLTEwMH0sIHtyOiAxLCBjOiA0LCBzOiAtMTAwfSxcblx0XHRcdHtyOiAwLCBjOiAwLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDEsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMiwgdDogJ2tleSd9LCB7cjogMCwgYzogMywgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiA0LCB0OiAnd2F0ZXInfVxuXHRcdFx0XTtcblx0XHR9ZWxzZSBpZiAodGhpcy5sZXZlbCA9PT0gMykge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdHtyOiAyLCBjOiAwLCBzOiA1MDB9LCB7cjogMiwgYzogNCwgczogNjAwfSxcblx0XHRcdHtyOiAwLCBjOiAwLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDEsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMiwgdDogJ2tleSd9LCB7cjogMCwgYzogMywgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiA0LCB0OiAnd2F0ZXInfVxuXHRcdFx0XTtcblx0XHR9ZWxzZSBpZiAodGhpcy5sZXZlbCA9PT0gNCkge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdHtyOiAxLCBjOiAwLCBzOiAtMTAwfSwge3I6IDEsIGM6IDEsIHM6IC0xMDB9LCB7cjogMSwgYzogMywgczogLTEwMH0sIHtyOiAxLCBjOiA0LCBzOiAtMTAwfSxcblx0XHRcdHtyOiAzLCBjOiAwLCBzOiAyMDB9LCB7cjogMywgYzogMiwgczogMjAwfSwge3I6IDMsIGM6IDQsIHM6IDIwMH0sXG5cdFx0XHR7cjogMCwgYzogMCwgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiAxLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDIsIHQ6ICdrZXknfSwge3I6IDAsIGM6IDMsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogNCwgdDogJ3dhdGVyJ31cblx0XHRcdF07XG5cdFx0fWVsc2UgaWYgKHRoaXMubGV2ZWwgPT09IDUpIHtcblx0XHRcdHJldHVybiBbXG5cdFx0XHR7cjogMiwgYzogMCwgczogNTAwfSwge3I6IDIsIGM6IDQsIHM6IDYwMH0sXG5cdFx0XHR7cjogMywgYzogMCwgczogMjAwfSwge3I6IDMsIGM6IDIsIHM6IDIwMH0sIHtyOiAzLCBjOiA0LCBzOiAyMDB9LFxuXHRcdFx0e3I6IDAsIGM6IDAsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMSwgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiAyLCB0OiAna2V5J30sIHtyOiAwLCBjOiAzLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDQsIHQ6ICd3YXRlcid9XG5cdFx0XHRdO1xuXHRcdH1lbHNlIGlmICh0aGlzLmxldmVsID09PSA2KSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0e3I6IDEsIGM6IDAsIHM6IC0xMDB9LCB7cjogMSwgYzogMSwgczogLTEwMH0sIHtyOiAxLCBjOiAzLCBzOiAtMTAwfSwge3I6IDEsIGM6IDQsIHM6IC0xMDB9LFxuXHRcdFx0e3I6IDIsIGM6IDAsIHM6IDUwMH0sIHtyOiAyLCBjOiA0LCBzOiA2MDB9LFxuXHRcdFx0e3I6IDAsIGM6IDAsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMSwgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiAyLCB0OiAna2V5J30sIHtyOiAwLCBjOiAzLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDQsIHQ6ICd3YXRlcid9XG5cdFx0XHRdO1xuXHRcdH1cblx0XHQvLyAganNjczpkaXNhYmxlXG5cdFx0cmV0dXJuIFtcblx0XHR7cjogMSwgYzogMCwgczogLTEwMH0sIHtyOiAxLCBjOiAxLCBzOiAtMTAwfSwge3I6IDEsIGM6IDMsIHM6IC0xMDB9LCB7cjogMSwgYzogNCwgczogLTEwMH0sXG5cdFx0e3I6IDIsIGM6IDAsIHM6IDUwMH0sIHtyOiAyLCBjOiA0LCBzOiA2MDB9LFxuXHRcdHtyOiAzLCBjOiAwLCBzOiAyMDB9LCB7cjogMywgYzogMiwgczogMjAwfSwge3I6IDMsIGM6IDQsIHM6IDIwMH0sXG5cdFx0e3I6IDAsIGM6IDAsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMSwgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiAyLCB0OiAna2V5J30sIHtyOiAwLCBjOiAzLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDQsIHQ6ICd3YXRlcid9XG5cdFx0XTtcblx0fTtcbn0pLmNhbGwoTGV2ZWwucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQGRlc2NyaXB0aW9uIFNjZW5lIFNpbmdsZXRvbiB1c2VkIGZvciBjaGFuZ2luZyB0aGUgc2NlbmUgdmlld1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTY2VuZSA9IChmdW5jdGlvbiBTY2VuZSgpIHtcblx0dmFyIGluc3RhbmNlID0gZnVuY3Rpb24gaW5zdGFuY2UoKSB7fTtcblx0dmFyIGxldmVsID0gbmV3IExldmVsKCk7XG5cdHZhciBvbkNoYXJhY3RlckNsaWNrZWQgPSBmdW5jdGlvbiBvbkNoYXJhY3RlckNsaWNrZWQoZWwpIHtcblx0XHR2YXIgcyA9IGVsLnRhcmdldC5zcmM7XG5cdFx0cGxheWVyLnNwcml0ZSA9IHMuc2xpY2Uocy5pbmRleE9mKCcvaW1hZ2VzLycpICsgMSwgcy5sZW5ndGgpO1xuXG5cdFx0RWwucmVtb3ZlQ2xhc3MoRWwuZ2V0RWxlbWVudHMoJ3NlbGVjdGVkLWNoYXInKSwgJ3NlbGVjdGVkLWNoYXInKTtcblx0XHRFbC5hZGRDbGFzcyhlbC50YXJnZXQsICdzZWxlY3RlZC1jaGFyJyk7XG5cdH07XG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gU2hvd3MgdGhlIENoYXJhY3RlciBzZWxlY3Rpb24gc2NlbmVcblx0ICovXG5cdGluc3RhbmNlLnN0YXJ0TWVudSA9IGZ1bmN0aW9uIHN0YXJ0TWVudSgpIHtcblx0XHR2YXIgY2hhcmFjdGVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NoYXInKTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGFyYWN0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjaGFyYWN0ZXJzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DaGFyYWN0ZXJDbGlja2VkKTtcblx0XHR9XG5cblx0XHRFbmdpbmUucmVzZXQoKTtcblxuXHRcdEVsLnNob3coJ2NoYXJfc2VsZWN0Jyk7XG5cdFx0RWwuaGlkZSgnbGV2ZWwnKTtcblx0XHRFbC5oaWRlKCdnYW1lb3ZlcicpO1xuXHRcdEVsLmhpZGUoJ2dhbWV3aW4nKTtcblx0XHRzY2VuZSA9ICdjaGFyX3NlbGVjdCc7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBTaG93cyB0aGUgR2FtZSBzY2VuZVxuXHQgKi9cblx0aW5zdGFuY2Uuc3RhcnRHYW1lID0gZnVuY3Rpb24gc3RhcnRHYW1lKHJlc2V0KSB7XG5cdFx0cmVzZXQgPSByZXNldCB8fCBmYWxzZTtcblxuXHRcdGlmIChyZXNldCkge1xuXHRcdFx0bGV2ZWwucmVzZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0TW9kZWwuc2V0KCdsZXZlbF9jb21wbGV0ZScsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRFbmdpbmUucHJlbG9hZCgpO1xuXHRcdHBsYXllci5yZXNwYXduKCk7XG5cblx0XHRsZXZlbC5hZGRFbnRpdGllcygpO1xuXHRcdEVuZ2luZS5lbnRpdGllcy5wdXNoKHVpKTtcblx0XHR1aS5zdGFydCgpO1xuXG5cdFx0RWwuc2hvdygnbGV2ZWwnKTtcblx0XHRFbC5oaWRlKCdjaGFyX3NlbGVjdCcpO1xuXHRcdEVsLmhpZGUoJ2dhbWVvdmVyJyk7XG5cdFx0RWwuaGlkZSgnZ2FtZXdpbicpO1xuXHRcdHNjZW5lID0gJ2xldmVsJztcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFNob3dzIHRoZSBHYW1lIE92ZXIgcG9wdXBcblx0ICovXG5cdGluc3RhbmNlLmVuZEdhbWUgPSBmdW5jdGlvbiBlbmRHYW1lKCkge1xuXHRcdEVsLnNob3coJ2dhbWVvdmVyJyk7XG5cdFx0RW5naW5lLnBhdXNlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBTaG93cyB0aGUgR2FtZSBXaW4gcG9wdXBcblx0ICovXG5cdGluc3RhbmNlLndpbkdhbWUgPSBmdW5jdGlvbiB3aW5HYW1lKCkge1xuXHRcdEVsLnNob3coJ2dhbWV3aW4nKTtcblx0XHRFbmdpbmUucGF1c2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFRoZSBwbGF5ZXIgcGlja2VkIHVwIHRoZSBrZXkuIFNob3cgc3RhciBleHBsb3Npb24gYW5kIGFkdmFuY2UgbGV2ZWwgYWZ0ZXIgdGltZW91dFxuXHQgKi9cblx0aW5zdGFuY2UubGV2ZWxDb21wbGV0ZSA9IGZ1bmN0aW9uIGxldmVsQ29tcGxldGUoKSB7XG5cdFx0TW9kZWwuc2V0KCdsZXZlbF9jb21wbGV0ZScsIHRydWUpO1xuXHRcdEVuZ2luZS5lbnRpdGllcy5wdXNoKG5ldyBFeHBsb3Npb24oMCwgMikpO1xuXHRcdHNldFRpbWVvdXQoaW5zdGFuY2UubmV4dExldmVsLCAxNTAwKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIEFkdmFuY2UgdG8gdGhlIG5leHQgbGV2ZWwgb3IgZW5kIHRoZSBnYW1lIGlmIG5vIG1vcmUgbGV2ZWxzXG5cdCAqL1xuXHRpbnN0YW5jZS5uZXh0TGV2ZWwgPSBmdW5jdGlvbiBuZXh0TGV2ZWwoKSB7XG5cdFx0bGV2ZWwubmV4dCgpO1xuXG5cdFx0aWYgKGxldmVsLmxldmVsID4gbGV2ZWwubGFzdExldmVsKSB7XG5cdFx0XHRpbnN0YW5jZS53aW5HYW1lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluc3RhbmNlLnN0YXJ0R2FtZSgpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gaW5zdGFuY2U7XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4qIEBkZXNjcmlwdGlvbiBBIHNlbnNvciB1c2VkIGFzIGEgY29sbGlzaW9uIGJveCB0aGF0IGNhbiBiZSByZW5kZXJlZCB0byB0aGUgc2NyZWVuIGZvciB0ZXN0aW5nXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGxvY2F0aW9uXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgbG9jYXRpb25cbiogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gSG93IGxvbmcgdGhlIHNlbnNvciBpc1xuKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSG93IHRhbGwgdGhlIHNlbnNvciBpc1xuKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFRoZSBvZmZzZXQgaW4gdGhlIHggZGlyZWN0aW9uXG4qIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0gVGhlIG9mZnNldCBpbiB0aGUgeSBkaXJlY3Rpb25cbiovXG52YXIgU2Vuc29yID0gZnVuY3Rpb24gU2Vuc29yKHgsIHksIHdpZHRoLCBoZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpIHtcblx0dGhpcy54ID0geDtcblx0dGhpcy55ID0geTtcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0dGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcblx0dGhpcy5vZmZzZXRZID0gb2Zmc2V0WTtcblx0dGhpcy5kZWJ1ZyA9IGZhbHNlO1xufTtcblxuKGZ1bmN0aW9uIFByb3RvdHlwZSgpIHtcblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW5kZXJzIHRoaXMgZW50aXR5IHRvIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtjb250ZXh0fSBjdHggLSBUaGUgY2FudmFzJ3MgY29udGV4dFxuXHQgKi9cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY3R4KSB7XG5cdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuXHRcdFx0Y3R4LnJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIHRoZSBzZW5zb3IncyBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge2ludH0geCAtIFRoZSB4IGxvY2F0aW9uXG5cdCAqIEBwYXJhbSB7aW50fSB5IC0gVGhlIHkgbG9jYXRpb25cblx0ICovXG5cdHRoaXMucG9zaXRpb24gPSBmdW5jdGlvbiBwb3NpdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geCArIHRoaXMub2Zmc2V0WDtcblx0XHR0aGlzLnkgPSB5ICsgdGhpcy5vZmZzZXRZO1xuXHR9O1xufSkuY2FsbChTZW5zb3IucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIHRoZSBvd25lcnMgc3ByaXRlIGFjY29yZGluZyB0byBwb3NpdGlvbiwgYWxwaGEgYW5kIGRpcmVjdGlvblxuKiBAY29uc3RydWN0b3JcbiovXG52YXIgUmVuZGVyID0gZnVuY3Rpb24gUmVuZGVyKG93bmVyKSB7XG5cdHRoaXMub3duZXIgPSBvd25lcjtcbn07XG5cbihmdW5jdGlvbiBQcm90b3R5cGUoKSB7XG5cdHZhciBwID0ge3g6IDAsIHk6IDB9O1xuXHQvKipcblx0ICAqIEBkZXNjcmlwdGlvbiBSZW5kZXJzIHRoZSBvd25lcidzIHNwcml0ZVxuXHQgICogQHBhcmFtIHtjb250ZXh0fSBjdHggLSBUaGUgY2FudmFzJ3MgY29udGV4dFxuXHQgICovXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGN0eCkge1xuXHRcdHZhciBmbGlwcGVkID0gdGhpcy5vd25lci5mbGlwcGVkID8gLTEgOiAxO1xuXHRcdHZhciBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguc2NhbGUoZmxpcHBlZCwgMSk7XG5cdFx0Y3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vd25lci5hbHBoYSB8fCAxO1xuXHRcdGN0eC5kcmF3SW1hZ2UoUmVzb3VyY2VzLmdldCh0aGlzLm93bmVyLnNwcml0ZSksIHBvcy54LCBwb3MueSwgMTAxLCAxNzEpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgZm9ybWF0dGVkIHBvc2l0aW9uXG5cdCAgKi9cblx0dGhpcy5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uKCkge1xuXHRcdHZhciBmbGlwcGVkID0gdGhpcy5vd25lci5mbGlwcGVkID8gLTEgOiAxO1xuXHRcdHAueCA9ICh0aGlzLm93bmVyLnggKyB0aGlzLm93bmVyLm9mZnNldFgpICogZmxpcHBlZDtcblx0XHRwLnggKz0gKGZsaXBwZWQgPT09IDEgPyAwIDogLTEwMSk7XG5cdFx0cC55ID0gdGhpcy5vd25lci55ICsgdGhpcy5vd25lci5vZmZzZXRZO1xuXHRcdHJldHVybiBwO1xuXHR9O1xufSkuY2FsbChSZW5kZXIucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gVGhlIGluZ2FtZSBpbmZvcm1hdGlvbiBkaXNwbGF5XG4qIEBjb25zdHJ1Y3RvclxuKi9cbnZhciBVSSA9IGZ1bmN0aW9uIFVJKCkge1xuXHR0aGlzLmtleXMgPSAwO1xuXHR0aGlzLmxldmVsVGltZSA9IDA7XG5cdHRoaXMudGltZSA9IDA7XG59O1xuXG4oZnVuY3Rpb24gUHJvdG90eXBlKCkge1xuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlc2V0cyB0aGUgbGV2ZWwgaW5mb3JtYXRpb24gYW5kIHN0YXJ0cyB0aGUgZ2FtZSB0aW1lclxuXHQgKi9cblx0dGhpcy5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuXHRcdHRoaXMua2V5cyA9IE1vZGVsLmdldCgnbGV2ZWwnKTtcblx0XHR0aGlzLmxldmVsVGltZSA9IE1vZGVsLmdldCgnbGV2ZWxfdG90YWxfdGltZScpO1xuXG5cdFx0dGhpcy5sZXZlbFRpbWVyID0gbmV3IFRpbWVyKDEsIHRoaXMubGV2ZWxUaW1lKTtcblx0XHR0aGlzLmxldmVsVGltZXIub24oJ0NPTVBMRVRFJywgdGhpcy5vblRpbWVyQ29tcGxldGUpO1xuXHRcdHRoaXMubGV2ZWxUaW1lci5zdGFydCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gVGhlIGxldmVsIHRpbWVyIGhhcyBjb21wbGV0ZWRcblx0ICovXG5cdHRoaXMub25UaW1lckNvbXBsZXRlID0gZnVuY3Rpb24gb25UaW1lckNvbXBsZXRlKCkge1xuXHRcdGlmICghTW9kZWwuZ2V0KCdsZXZlbF9jb21wbGV0ZScpKSB7XG5cdFx0XHRTY2VuZS5lbmRHYW1lKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gRm9ybWF0ZWQgc3RyaW5nIG9mIHRpbWUgbGVmdCAoZXhwZWN0cyA+MCAmJiA8NjAgc2Vjb25kcylcblx0ICogQHJldHVybnMge3N0cmluZ30gU2Vjb25kcyBsZWZ0IG9uIHRpbWVcblx0ICovXG5cdHRoaXMuZm9ybWF0dGVkVGltZSA9IGZ1bmN0aW9uIGZvcm1hdHRlZFRpbWUoKSB7XG5cdFx0dmFyIHRpbWUgPSBNYXRoLnJvdW5kKHRoaXMubGV2ZWxUaW1lci50aW1lKTtcblx0XHRyZXR1cm4gJzAwOicgKyAodGltZSA+IDkgPyB0aW1lIDogJzAnICsgdGltZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW5kZXJzIHRleHQgdG8gdGhlIHNjcmVlblxuXHQgKiBAcGFyYW0ge2NvbnRleHR9IGN0eCAtIFRoZSBjYW52YXMncyBjb250ZXh0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGRpc3BsYXlcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBsb2NhdGlvblxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGxvY2F0aW9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbiAtIFRoZSBjYW52YXMncyBjb250ZXh0XG5cdCAqL1xuXHR0aGlzLnRleHQgPSBmdW5jdGlvbiB0ZXh0KGN0eCwgc3RyaW5nLCB4LCB5LCBhbGlnbikge1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LmZvbnQgPSAnMzBweCBDb21pYyBTYW5zIE1TJztcblx0XHRpZiAoYWxpZ24gPT09ICdsZWZ0JyB8fCBhbGlnbiA9PT0gJ3JpZ2h0JyB8fCBhbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBhbGlnbjtcblx0XHR9XG5cdFx0Y3R4LmZpbGxUZXh0KHN0cmluZywgeCwgeSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIHRpbWVyIGFuZCBrZXkgaW5mb3JtYXRpb25cblx0ICogQHBhcmFtIHtpbnR9IGR0IC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZVxuXHQgKi9cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcblx0XHRpZiAoIU1vZGVsLmdldCgnbGV2ZWxfY29tcGxldGUnKSkge1xuXHRcdFx0dGhpcy5rZXlzID0gTW9kZWwuZ2V0KCdsZXZlbCcpO1xuXHRcdFx0dGhpcy5sZXZlbFRpbWVyLnVwZGF0ZShkdCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmVuZGVycyB0aGlzIGVudGl0eSB0byB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7Y29udGV4dH0gY3R4IC0gVGhlIGNhbnZhcydzIGNvbnRleHRcblx0ICovXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGN0eCkge1xuXHRcdHRoaXMudGV4dChjdHgsICdLZXlzOiB4JyArIHRoaXMua2V5cywgMCwgMzApO1xuXHRcdHRoaXMudGV4dChjdHgsICdUaW1lOiAnICsgdGhpcy5mb3JtYXR0ZWRUaW1lKCksIEVuZ2luZS53aWR0aCwgMzAsICdyaWdodCcpO1xuXHR9O1xufSkuY2FsbChVSS5wcm90b3R5cGUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4qIEBkZXNjcmlwdGlvbiBLZXkgZW50aXR5XG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge2ludH0gcm93IC0gVGhlIGluaXRpYWwgcm93XG4qIEBwYXJhbSB7aW50fSBjb2wgLSBUaGUgaW5pdGlhbCBjb2x1bW5cbiovXG52YXIgS2V5ID0gZnVuY3Rpb24gS2V5KHJvdywgY29sKSB7XG5cdHRoaXMuZW50aXR5ID0gbmV3IEVudGl0eSh0aGlzLFxuXHRcdEdyaWQuZ2V0WEZyb21Db2x1bW4oY29sKSxcblx0XHRHcmlkLmdldFlGcm9tUm93KHJvdyksXG5cdFx0J2ltYWdlcy9LZXkucG5nJyxcblx0XHQwLFxuXHRcdC0oMTcxIC0gMTM4KSAtIEdyaWQub2Zmc2V0WSk7XG5cdHRoaXMuc2Vuc29yID0gbmV3IFNlbnNvcigwLCAwLCA1MCwgMzAsIDI1LCAyNSk7XG5cdHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyKHRoaXMpO1xufTtcblxuKGZ1bmN0aW9uIFByb3RvdHlwZSgpIHtcblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgdGhpcyBlbnRpdHkgaXMgY29sbGlkaW5nIHdpdGggdGhlIHBsYXllclxuXHQgKiBAcGFyYW0ge2ludH0gZHQgLSBUaW1lIHNpbmNlIGxhc3QgdXBkYXRlXG5cdCAqL1xuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkdCkge1xuXHRcdHRoaXMuc2Vuc29yLnBvc2l0aW9uKHRoaXMueCwgdGhpcy55KTtcblx0XHRpZiAocGxheWVyICYmIHBsYXllci5pc0FsaXZlICYmIHRoaXMuaXNBbGl2ZSkge1xuXHRcdFx0aWYgKENvbGxpc2lvbi5pc0NvbGxpZGluZyh0aGlzLnNlbnNvciwgcGxheWVyLnNlbnNvcikpIHtcblx0XHRcdFx0dGhpcy5pc0FsaXZlID0gZmFsc2U7XG5cdFx0XHRcdHBsYXllci5oaXQoJ2tleScpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlbmRlcnMgdGhpcyBlbnRpdHkgdG8gdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge2NvbnRleHR9IGN0eCAtIFRoZSBjYW52YXMncyBjb250ZXh0XG5cdCAqL1xuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjdHgpIHtcblx0XHR0aGlzLnJlbmRlcmVyLnJlbmRlcihjdHgpO1xuXHRcdHRoaXMuc2Vuc29yLnJlbmRlcihjdHgpO1xuXHR9O1xufSkuY2FsbChLZXkucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gV2F0ZXIgZW50aXR5XG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge2ludH0gcm93IC0gVGhlIGluaXRpYWwgcm93XG4qIEBwYXJhbSB7aW50fSBjb2wgLSBUaGUgaW5pdGlhbCBjb2x1bW5cbiovXG52YXIgV2F0ZXIgPSBmdW5jdGlvbiBXYXRlcihyb3csIGNvbCkge1xuXHR0aGlzLmVudGl0eSA9IG5ldyBFbnRpdHkodGhpcyxcblx0XHRHcmlkLmdldFhGcm9tQ29sdW1uKGNvbCksXG5cdFx0R3JpZC5nZXRZRnJvbVJvdyhyb3cpLFxuXHRcdCdpbWFnZXMvS2V5LnBuZycsXG5cdFx0MCxcblx0XHQtKDE3MSAtIDEzOCkgLSBHcmlkLm9mZnNldFkpO1xuXHR0aGlzLnNlbnNvciA9IG5ldyBTZW5zb3IoMCwgMCwgNTAsIDMwLCAyNSwgMjUpO1xufTtcblxuKGZ1bmN0aW9uIFByb3RvdHlwZSgpIHtcblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgdGhpcyBlbnRpdHkgaXMgY29sbGlkaW5nIHdpdGggdGhlIHBsYXllclxuXHQgKiBAcGFyYW0ge2ludH0gZHQgLSBUaW1lIHNpbmNlIGxhc3QgdXBkYXRlXG5cdCAqL1xuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkdCkge1xuXHRcdHRoaXMuc2Vuc29yLnBvc2l0aW9uKHRoaXMueCwgdGhpcy55KTtcblxuXHRcdGlmIChwbGF5ZXIgJiYgcGxheWVyLmlzQWxpdmUpIHtcblx0XHRcdGlmIChDb2xsaXNpb24uaXNDb2xsaWRpbmcodGhpcy5zZW5zb3IsIHBsYXllci5zZW5zb3IpKSB7XG5cdFx0XHRcdHBsYXllci5oaXQoJ3dhdGVyJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmVuZGVycyB0aGlzIGVudGl0eSB0byB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7Y29udGV4dH0gY3R4IC0gVGhlIGNhbnZhcydzIGNvbnRleHRcblx0ICovXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGN0eCkge1xuXHRcdHRoaXMuc2Vuc29yLnJlbmRlcihjdHgpO1xuXHR9O1xufSkuY2FsbChXYXRlci5wcm90b3R5cGUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gRW5lbXkgZW50aXR5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7aW50fSByb3cgLSBUaGUgaW5pdGlhbCByb3dcbiAqIEBwYXJhbSB7aW50fSBjb2wgLSBUaGUgaW5pdGlhbCBjb2x1bW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZCAtIFRoZSBpbml0aWFsIHNwZWVkXG4gKi9cbnZhciBFbmVteSA9IGZ1bmN0aW9uIEVuZW15KHJvdywgY29sLCBzcGVlZCkge1xuXHR0aGlzLmVudGl0eSA9IG5ldyBFbnRpdHkodGhpcyxcblx0XHRHcmlkLmdldFhGcm9tQ29sdW1uKGNvbCksXG5cdFx0R3JpZC5nZXRZRnJvbVJvdyhyb3cpLFxuXHRcdCdpbWFnZXMvZW5lbXktYnVnLnBuZycsXG5cdFx0MCwgLSgxNzEgLSAxMzgpIC0gR3JpZC5vZmZzZXRZKTtcblx0dGhpcy5yb3cgPSByb3c7XG5cdHRoaXMuc3BlZWQgPSBzcGVlZDtcblx0dGhpcy5mbGlwcGVkID0gc3BlZWQgPCAwO1xuXHR0aGlzLnNlbnNvciA9IG5ldyBTZW5zb3IoMCwgMCwgNTAsIDUwLCAyNSwgMTIpO1xuXHR0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcih0aGlzKTtcbn07XG5cbihmdW5jdGlvbiBQcm90b3R5cGUoKSB7XG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGlmIHRoaXMgZW50aXR5IGlzIGNvbGxpZGluZyB3aXRoIHRoZSBwbGF5ZXIgYW5kIGtlZXBzIHRhcmdldCBvbiBzY3JlZW4gYnkgd3JhcHBpbmcgeCBsb2NhdGlvblxuXHQgKiBAcGFyYW0ge2ludH0gZHQgLSBUaW1lIHNpbmNlIGxhc3QgdXBkYXRlXG5cdCAqL1xuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkdCkge1xuXHRcdHRoaXMueCArPSBkdCAqIHRoaXMuc3BlZWQ7XG5cblx0XHQvLyAgV3JhcFxuXHRcdGlmICh0aGlzLnggPiAoR3JpZC5jb2x1bW5zICogR3JpZC5jZWxsV2lkdGgpICsgR3JpZC5jZWxsV2lkdGgpIHtcblx0XHRcdHRoaXMueCA9IEdyaWQuZ2V0WEZyb21Db2x1bW4oMCkgLSBHcmlkLmNlbGxXaWR0aDtcblx0XHR9IGVsc2UgaWYgKHRoaXMueCA8IC1HcmlkLmNlbGxXaWR0aCkge1xuXHRcdFx0dGhpcy54ID0gKEdyaWQuY29sdW1ucyAqIEdyaWQuY2VsbFdpZHRoKSArIEdyaWQuY2VsbFdpZHRoO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Vuc29yLnBvc2l0aW9uKHRoaXMueCwgdGhpcy55KTtcblx0XHRpZiAocGxheWVyICYmIHBsYXllci5pc0FsaXZlKSB7XG5cdFx0XHRpZiAoQ29sbGlzaW9uLmlzQ29sbGlkaW5nKHRoaXMuc2Vuc29yLCBwbGF5ZXIuc2Vuc29yKSkge1xuXHRcdFx0XHRwbGF5ZXIuaGl0KCdlbmVteScpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlbmRlcnMgdGhpcyBlbnRpdHkgdG8gdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge2NvbnRleHR9IGN0eCAtIFRoZSBjYW52YXMncyBjb250ZXh0XG5cdCAqL1xuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjdHgpIHtcblx0XHR0aGlzLnJlbmRlcmVyLnJlbmRlcihjdHgpO1xuXHRcdHRoaXMuc2Vuc29yLnJlbmRlcihjdHgpO1xuXHR9O1xufSkuY2FsbChFbmVteS5wcm90b3R5cGUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4qIEBkZXNjcmlwdGlvbiBQbGF5ZXIgZW50aXR5XG4qIEBjb25zdHJ1Y3RvclxuKi9cbnZhciBQbGF5ZXIgPSBmdW5jdGlvbiBQbGF5ZXIoKSB7XG5cdHRoaXMuZW50aXR5ID0gbmV3IEVudGl0eSh0aGlzLFxuXHRcdDAsXG5cdFx0MCxcblx0XHQnaW1hZ2VzL2NoYXItYm95LnBuZycsXG5cdFx0MCxcblx0XHQtKDE3MSAtIDEzOCkgLSBHcmlkLm9mZnNldFkpO1xuXHR0aGlzLmlzQWxpdmUgPSBmYWxzZTtcblx0dGhpcy5hbHBoYSA9IDA7XG5cdHRoaXMuc2Vuc29yID0gbmV3IFNlbnNvcigwLCAwLCA1MCwgMzAsIDI1LCAyNSk7XG5cdHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyKHRoaXMpO1xuXHR0aGlzLmJsaW5rVGltZXIgPSBuZXcgVGltZXIoNSwgMC4yKTtcblxuXHR2YXIgcmVmID0gdGhpcztcblxuXHR2YXIgb25CbGlua1RpbWVyQ29tcGxldGUgPSBmdW5jdGlvbiBvbkJsaW5rVGltZXJDb21wbGV0ZSgpIHtcblx0XHRyZWYuYWxwaGEgPSAxO1xuXHRcdHJlZi5pc0FsaXZlID0gdHJ1ZTtcblx0fTtcblxuXHR2YXIgb25CbGlua1RpbWVyVXBkYXRlID0gZnVuY3Rpb24gb25CbGlua1RpbWVyVXBkYXRlKCkge1xuXHRcdHJlZi5hbHBoYSA9IChyZWYuYWxwaGEgPT09IDAuNCA/IDEgOiAwLjQpO1xuXHR9O1xuXG5cdHZhciBvbktleVVwID0gZnVuY3Rpb24gb25LZXlVcChlKSB7XG5cdFx0cmVmLmhhbmRsZUlucHV0KGUpO1xuXHR9O1xuXG5cdHRoaXMuYmxpbmtUaW1lci5vbignQ09NUExFVEUnLCBvbkJsaW5rVGltZXJDb21wbGV0ZSk7XG5cdHRoaXMuYmxpbmtUaW1lci5vbignVVBEQVRFJywgb25CbGlua1RpbWVyVXBkYXRlKTtcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBvbktleVVwKTtcblxuXHR0aGlzLnJlc3Bhd24oKTtcbn07XG5cbihmdW5jdGlvbiBQcm90b3R5cGUoKSB7XG5cdHZhciBpbnB1dE1hcCA9IHtcblx0XHQzNzogJ2xlZnQnLFxuXHRcdDM4OiAndXAnLFxuXHRcdDM5OiAncmlnaHQnLFxuXHRcdDQwOiAnZG93bidcblx0fTtcblxuXHR2YXIgaW5wdXRSZXNwb25zZU1hcCA9IHtcblx0XHRsZWZ0OiB7YXhpczogJ3gnLCBkaXI6IC0xfSxcblx0XHR1cDoge2F4aXM6ICd5JywgZGlyOiAtMX0sXG5cdFx0cmlnaHQ6IHtheGlzOiAneCcsIGRpcjogMX0sXG5cdFx0ZG93bjoge2F4aXM6ICd5JywgZGlyOiAxfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmVzZXRzIHRoZSBwbGF5ZXIgdG8gdGhlIGluaXRpYWwgcG9zaXRpb25cblx0ICovXG5cdHRoaXMucmVzcGF3biA9IGZ1bmN0aW9uIHJlc3Bhd24oKSB7XG5cdFx0dGhpcy5zZW5zb3IueCA9IHRoaXMueCA9IEdyaWQuZ2V0WEZyb21Db2x1bW4oMik7XG5cdFx0dGhpcy5zZW5zb3IueSA9IHRoaXMueSA9IEdyaWQuZ2V0WUZyb21Sb3coNSk7XG5cdFx0dGhpcy5pc0FsaXZlID0gZmFsc2U7XG5cdFx0dGhpcy5hbHBoYSA9IDAuNDtcblx0XHR0aGlzLmJsaW5rVGltZXIuc3RhcnQoKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIEEgZW50aXR5IGhhcyBoaXQgdGhlIHBsYXllclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW52b2tlciAtIFR5cGUgb2Ygb2JqZWN0IHRoYXQgaGl0IHRoZSBwbGF5ZXJcblx0ICovXG5cdHRoaXMuaGl0ID0gZnVuY3Rpb24gaGl0KGludm9rZXIpIHtcblx0XHRpZiAoaW52b2tlciA9PT0gJ3dhdGVyJyB8fCBpbnZva2VyID09PSAnZW5lbXknKSB7XG5cdFx0XHR0aGlzLnJlc3Bhd24oKTtcblx0XHR9ZWxzZSBpZiAoaW52b2tlciA9PT0gJ2tleScpIHtcblx0XHRcdFNjZW5lLmxldmVsQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBHZXRzIHRoZSBwb3NpdGlvbiBvbiB0aGUgZ3JpZCBiYXNlZCBvbiBwbGF5ZXIncyBpbnB1dFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIFRoZSB4IG9yIHkgYXhpc1xuXHQgKiBAcGFyYW0ge2lucHV0fSBkaXIgLSBUaGUgcG9zaXRpdmUgb3IgbmVnYXRpdmUgZGlyZWN0aW9uXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBmaW5hbCBwb3NpdGlvblxuXHQgKi9cblx0dGhpcy5nZXRNb3ZlbWVudCA9IGZ1bmN0aW9uIGdldE1vdmVtZW50KGF4aXMsIGRpcikge1xuXHRcdHZhciB2O1xuXG5cdFx0aWYgKGF4aXMgPT09ICd4Jykge1xuXHRcdFx0diA9IE1hdGguZmxvb3IodGhpcy54IC8gR3JpZC5jZWxsV2lkdGgpICsgZGlyO1xuXHRcdFx0cmV0dXJuIEdyaWQuZ2V0WEZyb21Db2x1bW4odik7XG5cdFx0fVxuXG5cdFx0diA9IE1hdGguZmxvb3IodGhpcy55IC8gR3JpZC5jZWxsSGVpZ2h0KSArIGRpcjtcblx0XHRyZXR1cm4gR3JpZC5nZXRZRnJvbVJvdyh2KTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIENoYW5nZXMgdGhlIHBsYXllciBwb3NpdGlvbiBiYXNlZCBvbiBpbnB1dFxuXHQgKiBAcGFyYW0ge2V2ZW50fSBlIC0gVGhlIGV2ZW50IHRoYXQgb2NjdXJlZFxuXHQgKi9cblx0dGhpcy5oYW5kbGVJbnB1dCA9IGZ1bmN0aW9uIGhhbmRsZUlucHV0KGUpIHtcblx0XHR2YXIgaW5wdXQgPSBpbnB1dE1hcFtlLmtleUNvZGVdO1xuXHRcdGlmIChpbnB1dCAmJiB0aGlzLmlzQWxpdmUgPT09IHRydWUgJiYgIU1vZGVsLmdldCgnbGV2ZWxfY29tcGxldGUnKSkge1xuXHRcdFx0dmFyIG1hcCA9IGlucHV0UmVzcG9uc2VNYXBbaW5wdXRdO1xuXG5cdFx0XHQvLyAgTW92ZW1lbnRcblx0XHRcdGlmIChtYXAuaGFzT3duUHJvcGVydHkoJ2F4aXMnKSkge1xuXHRcdFx0XHR0aGlzW21hcC5heGlzXSA9IHRoaXMuZ2V0TW92ZW1lbnQobWFwLmF4aXMsIG1hcC5kaXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIHBsYXllcnMgdGltZXIgYW5kIHNlbnNvclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHQgLSBUaW1lIHNpbmNlIGxhc3QgdXBkYXRlXG5cdCAqL1xuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkdCkge1xuXHRcdHRoaXMuc2Vuc29yLnBvc2l0aW9uKHRoaXMueCwgdGhpcy55KTtcblx0XHRpZiAoIXRoaXMuaXNBbGl2ZSkge1xuXHRcdFx0dGhpcy5ibGlua1RpbWVyLnVwZGF0ZShkdCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmVuZGVycyB0aGlzIGVudGl0eSB0byB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7Y29udGV4dH0gY3R4IC0gVGhlIGNhbnZhcydzIGNvbnRleHRcblx0ICovXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGN0eCkge1xuXHRcdHRoaXMucmVuZGVyZXIucmVuZGVyKGN0eCk7XG5cdFx0dGhpcy5zZW5zb3IucmVuZGVyKGN0eCk7XG5cdH07XG59KS5jYWxsKFBsYXllci5wcm90b3R5cGUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4qIEBkZXNjcmlwdGlvbiBTdGFyIGVudGl0eVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtpbnR9IHJvdyAtIFRoZSBpbml0aWFsIHJvd1xuKiBAcGFyYW0ge2ludH0gY29sIC0gVGhlIGluaXRpYWwgY29sdW1uXG4qL1xudmFyIFN0YXIgPSBmdW5jdGlvbiBTdGFyKHJvdywgY29sKSB7XG5cdHRoaXMuZW50aXR5ID0gbmV3IEVudGl0eSh0aGlzLFxuXHRcdEdyaWQuZ2V0WEZyb21Db2x1bW4oY29sKSxcblx0XHRHcmlkLmdldFlGcm9tUm93KHJvdyksXG5cdFx0J2ltYWdlcy9TdGFyLnBuZycsXG5cdFx0MCxcblx0XHQtKDE3MSAtIDEzOCkgLSBHcmlkLm9mZnNldFkpO1xuXHR0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcih0aGlzKTtcblx0dGhpcy5zcGVlZCA9IDUwMDtcblx0dGhpcy5hbmdsZSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDE4MCkgKiBNYXRoLlBJIC8gMTgwO1xufTtcblxuKGZ1bmN0aW9uIFByb3RvdHlwZSgpIHtcblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBNb3ZlcyB0aGUgc3RhciBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhbmdsZSBhbmQgbG93ZXJzIG9wYWNpdHlcblx0ICogQHBhcmFtIHtpbnR9IGR0IC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZVxuXHQgKi9cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcblx0XHR0aGlzLnggKz0gdGhpcy5zcGVlZCAqIE1hdGguY29zKHRoaXMuYW5nbGUpICogZHQ7XG5cdFx0dGhpcy55ICs9IHRoaXMuc3BlZWQgKiBNYXRoLnNpbih0aGlzLmFuZ2xlKSAqIGR0O1xuXHRcdHRoaXMuYWxwaGEgPSBNYXRoLm1heCgwLjAxLCB0aGlzLmFscGhhIC0gMSAqIGR0KTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlbmRlcnMgdGhpcyBlbnRpdHkgdG8gdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge2NvbnRleHR9IGN0eCAtIFRoZSBjYW52YXMncyBjb250ZXh0XG5cdCAqL1xuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjdHgpIHtcblx0XHR0aGlzLnJlbmRlcmVyLnJlbmRlcihjdHgpO1xuXHR9O1xufSkuY2FsbChTdGFyLnByb3RvdHlwZSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiogQGRlc2NyaXB0aW9uIEtleSBlbnRpdHlcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7aW50fSByb3cgLSBUaGUgaW5pdGlhbCByb3dcbiogQHBhcmFtIHtpbnR9IGNvbCAtIFRoZSBpbml0aWFsIGNvbHVtblxuKi9cbnZhciBFeHBsb3Npb24gPSBmdW5jdGlvbiBFeHBsb3Npb24ocm93LCBjb2wpe1xuICAgIHRoaXMuc3RhcnMgPSBbXTtcbiAgICB0aGlzLmFkZFN0YXJzKHJvdywgY29sLCAxMCk7XG59O1xuXG4oZnVuY3Rpb24gUHJvdG90eXBlKCkge1xuICAgIFxuICAgIC8qKlxuICAgICogQGRlc2NyaXB0aW9uIEFkZHMgdGhlIHN0YXJzXG4gICAgKiBAcGFyYW0ge2ludH0gcm93IC0gVGhlIHkgbG9jYXRpb25cbiAgICAqIEBwYXJhbSB7aW50fSBjb2wgLSBUaGUgeCBsb2NhdGlvblxuICAgICogQHBhcmFtIHtpbnR9IHRvdGFsIC0gQW1vdW50IG9mIHN0YXJzXG4gICAgKi9cbiAgICB0aGlzLmFkZFN0YXJzID0gZnVuY3Rpb24gYWRkU3RhcnMocm93LCBjb2wsIHRvdGFsKXtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvcihpPTA7IGk8dG90YWw7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLnN0YXJzLnB1c2gobmV3IFN0YXIocm93LCBjb2wpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGRlc2NyaXB0aW9uIE1vdmVzIGFsbCB0aGUgc3RhcnNcbiAgICAqIEBwYXJhbSB7aW50fSBkdCAtIFRpbWUgc2luY2UgbGFzdCB1cGRhdGVcbiAgICAqL1xuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGR0KSB7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuc3RhcnMubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYodG90YWwgPiAwKXtcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhcnNbMF0uYWxwaGEgPD0gMC4wMSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFycyA9IFtdO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFyc1tpXS51cGRhdGUoZHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgKiBAZGVzY3JpcHRpb24gUmVuZGVycyB0aGUgc3RhcnMgdG8gdGhlIGNhbnZhc1xuICAgICogQHBhcmFtIHtjb250ZXh0fSBjdHggLSBUaGUgY2FudmFzJ3MgY29udGV4dFxuICAgICovXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY3R4KSB7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuc3RhcnMubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yKGk9MDsgaTx0b3RhbDsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMuc3RhcnNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KS5jYWxsKEV4cGxvc2lvbi5wcm90b3R5cGUpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBTY2VuZSA9IFNjZW5lIHx8IHt9O1xudmFyIEVsID0gRWwgfHwge307XG52YXIgVUkgPSBVSSB8fCB7fTtcbnZhciBQbGF5ZXIgPSBQbGF5ZXIgfHwge307XG52YXIgcGxheWVyID0gbmV3IFBsYXllcigpO1xudmFyIHVpID0gbmV3IFVJKCk7XG52YXIgc2NlbmUgPSAnJztcbnZhciBBcHAgPSAoZnVuY3Rpb24gQXBwKCkge1xuXHR2YXIgb25QbGF5Q2xpY2tlZCA9IGZ1bmN0aW9uIG9uUGxheUNsaWNrZWQoKSB7XG5cdFx0U2NlbmUuc3RhcnRHYW1lKHRydWUpO1xuXHR9O1xuXHR2YXIgb25SZXBsYXlDbGlja2VkID0gZnVuY3Rpb24gb25SZXBsYXlDbGlja2VkKCkge1xuXHRcdFNjZW5lLnN0YXJ0R2FtZSgpO1xuXHR9O1xuXHR2YXIgb25NZW51Q2xpY2tlZCA9IGZ1bmN0aW9uIG9uTWVudUNsaWNrZWQoKSB7XG5cdFx0U2NlbmUuc3RhcnRNZW51KCk7XG5cdH07XG5cblx0RWwuYWRkTGlzdGVuZXIoRWwuZ2V0RWxlbWVudHMoJ2J0bi1wbGF5JylbMF0sICdjbGljaycsIG9uUGxheUNsaWNrZWQpO1xuXHRFbC5hZGRMaXN0ZW5lcihFbC5nZXRFbGVtZW50cygnYnRuLXJlcGxheScpWzBdLCAnY2xpY2snLCBvblJlcGxheUNsaWNrZWQpO1xuXHRFbC5hZGRMaXN0ZW5lcihFbC5nZXRFbGVtZW50cygnYnRuLW1lbnUnKSwgJ2NsaWNrJywgb25NZW51Q2xpY2tlZCk7XG5cblx0Ly9cdERlZmF1bHQgc2hvdyB0aGUgc3RhcnQgbWVudVxuXHRTY2VuZS5zdGFydE1lbnUoKTtcblx0Ly9cdFNjZW5lLnN0YXJ0R2FtZSgpO1xufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
