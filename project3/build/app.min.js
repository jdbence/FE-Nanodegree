'use strict';
/**
 * @description El Singleton used for manipulating DOM elements
 * @constructor
 */
var El = (function El() {
	var instance = function instance() {};

	/**
	 * @description Removes the className from each element in the array
	 * @param {array} elements - Array of DOM elements
	 * @param {string} className - Class to remove
	 */
	instance.removeClass = function removeClass(elements, className) {
		var i, c;
		if (elements) {
			if (!this.isHTMLCollection(elements)) {
				elements = [elements];
			}
			for (i = 0; i < elements.length; i++) {
				c = elements[i].className.replace(' ' + className, '');
				elements[i].className = c;
			}
		}
	};

	/**
	 * @description Adds the className on each element in the array
	 * @param {array} elements - Array of DOM elements
	 * @param {string} className - Class to add
	 */
	instance.addClass = function addClass(elements, className) {
		var i;

		if (elements) {
			if (!this.isHTMLCollection(elements)) {
				elements = [elements];
			}
			for (i = 0; i < elements.length; i++) {
				if (elements[i].className.indexOf(' ' + className) < 0) {
					elements[i].className += ' ' + className;
				}
			}
		}
	};

	/**
	 * @description Adds a listener on the element
	 * @param {array} elements - Array of DOM elements
	 * @param {string} event - Event to listen for
	 * @param {function} callback - Function to call when the event is captured
	 */
	instance.addListener = function addListener(elements, event, callback) {
		var i;

		if (elements) {
			if (elements.length === undefined) {
				elements = [elements];
			}
			for (i = 0; i < elements.length; i++) {
				elements[i].addEventListener(event, callback);
			}
		}
	};

	/**
	 * @description Removes the hidden class from the elements with the given className or #ID
	 * @param {string} identifier - The elements to find
	 */
	instance.show = function show(identifier) {
		this.removeClass(this.getElements(identifier), 'hidden');
	};

	/**
	 * @description Adds the hidden class on the elements with the given className or #ID
	 * @param {string} identifier - The elements to find
	 */
	instance.hide = function hide(identifier) {
		this.addClass(this.getElements(identifier), 'hidden');
	};

	/**
	 * @description Finds all the elements with the className or #ID
	 * @param {string} identifier - The elements to find
	 */
	instance.getElements = function getElements(identifier) {
		if (this.isString(identifier)) {
			if (identifier.indexOf('#') !== -1) {
				return document.getElementById(identifier);
			}
			return document.getElementsByClassName(identifier);
		}
		return null;
	};

	/**
	 * @description Checks if the variable is a string
	 * @param {string} variable - The variable to check
	 */
	instance.isString = function isString(variable) {
		return this.isType(variable, '[object String]');
	};

	/**
	 * @description Checks if the variable is a HTMLCollection
	 * @param {string} variable - The variable to check
	 */
	instance.isHTMLCollection = function isHTMLCollection(variable) {
		return this.isType(variable, '[object HTMLCollection]');
	};

	/**
	 * @description Checks if the variable is the type
	 * @param {string} variable - The variable to check
	 */
	instance.isType = function isType(variable, type) {
		return Object.prototype.toString.call(variable) === type;
	};

	return instance;
})();

'use strict';
/**
* @description Entity sets all default variables to the owner
* @constructor
* @param {object} owner - The initial row
* @param {number} x - The initial x location
* @param {number} y - The initial y location
* @param {string} sprite - The display sprite
* @param {number} offsetX - The initial x offset
* @param {number} offsetY - The initial y offset
*/
var Entity = function Entity(owner, x, y, sprite, offsetX, offsetY) {
	this.owner = owner;
	owner.x = x;
	owner.y = y;
	owner.sprite = sprite || null;
	owner.offsetX = offsetX || 0;
	owner.offsetY = offsetY || 0;
	owner.flipped = false;
	owner.alpha = 1;
	owner.isAlive = true;
	owner.speed = 0;
	owner.angle = 0;
};

'use strict';
/* Resources.js
 * This is simple an image loading utility. It eases the process of loading
 * image files so that they can be used within your game. It also includes
 * a simple "caching" layer so it will reuse cached images if you attempt
 * to load the same image multiple times.
 */
(function Resources() {
	var resourceCache = {};
	var loading = [];
	var readyCallbacks = [];

	/* This function determines if all of the images that have been requested
	   * for loading have in fact been completed loaded.
	   */
	function isReady() {
		var ready = true;
		for (var k in resourceCache) {
			if (resourceCache.hasOwnProperty(k) &&
			!resourceCache[k]) {
				ready = false;
			}
		}
		return ready;
	}

	/* This is our private image loader function, it is
	   * called by the public image loader function.
	   */
	function _load(url) {
		if (!resourceCache[url]) {
			/* This URL has not been previously loaded and is not present
			       * within our cache; we'll need to load this image.
			       */
			var img = new Image();
			img.onload = function onImageLoad() {
				/* Once our image has properly loaded, add it to our cache
				         * so that we can simply return this image if the developer
				         * attempts to load this file in the future.
				         */
				resourceCache[url] = img;

				/* Once the image is actually loaded and properly cached,
				         * call all of the onReady() callbacks we have defined.
				         */
				if (isReady()) {
					readyCallbacks.forEach(function callCallbacks(func) { func(); });
				}
			};

			/* Set the initial cache value to false, this will change when
			       * the image's onload event handler is called. Finally, point
			       * the images src attribute to the passed in URL.
			       */
			resourceCache[url] = false;
			img.src = url;
		} else {
			return resourceCache[url];
		}
	}

	/* This is the publicly accessible image loading function. It accepts
	   * an array of strings pointing to image files or a string for a single
	   * image. It will then call our private image loading function accordingly.
	   */
	function load(urlOrArr) {
		if (urlOrArr instanceof Array) {
			/* If the developer passed in an array of images
			       * loop through each value and call our image
			       * loader on that image file
			       */
			urlOrArr.forEach(function loadURL(url) {
				_load(url);
			});
		} else {
			/* The developer did not pass an array to this function,
			       * assume the value is a string and call our image loader
			       * directly.
			       */
			_load(urlOrArr);
		}
	}

	/* This is used by developer's to grab references to images they know
	   * have been previously loaded. If an image is cached, this functions
	   * the same as calling load() on that URL.
	   */
	function get(url) {
		return resourceCache[url];
	}

	/* This function will add a function to the callback stack that is called
	   * when all requested images are properly loaded.
	   */
	function onReady(func) {
		readyCallbacks.push(func);
	}

	/* This object defines the publicly accessible functions available to
	   * developers by creating a global Resources object.
	   */
	window.Resources = {
		load: load,
		get: get,
		onReady: onReady,
		isReady: isReady
	};
})();

'use strict';
/**
 * @description Collision Singleton used for checking collision between two sensors
 * @constructor
 */
var Collision = (function Prototype() {
	var instance = function instance() {};
	/**
	 * @description Uses box collision to check if two sensors are touching
	 * @param {Senor} sensorA - Bounding rect A
	 * @param {Senor} sensorB - Bounding rect B
	 * @returns {boolean} based on sensor overlap
	 */
	instance.isColliding = function isColliding(sensorA, sensorB) {
		return (sensorA.x < sensorB.x + sensorB.width &&
			sensorA.x + sensorB.width > sensorB.x &&
			sensorA.y < sensorB.y + sensorB.height &&
			sensorA.height + sensorA.y > sensorB.y);
	};
	return instance;
})();

'use strict';
/* Engine.js
 * This file provides the game loop functionality (update entities and render),
 * draws the initial game board on the screen, and then calls the update and
 * render methods on your player and enemy objects (defined in your app.js).
 *
 * A game engine works by drawing the entire game screen over and over, kind of
 * like a flipbook you may have created as a kid. When your player moves across
 * the screen, it may look like just that image/character is moving or being
 * drawn but that is not the case. What's really happening is the entire "scene"
 * is being drawn over and over, presenting the illusion of animation.
 *
 * This engine is available globally via the Engine variable and it also makes
 * the canvas' context (ctx) object globally available to make writing app.js
 * a little simpler to work with.
 */

var Engine = (function Engine(global) {
	/* Predefine the variables we'll be using within this scope,
	 * create the canvas element, grab the 2D context for that canvas
	 * set the canvas elements height/width and add it to the DOM.
	 */
	var doc = global.document,
		win = global.window,
		canvas = doc.createElement('canvas'),
		ctx = canvas.getContext('2d'),
		lastTime,
		running = false,
		instance = function instance() {};

	instance.entities = [];
	instance.width = canvas.width = 505;
	instance.height = canvas.height = 606;
	canvas.className += ' canvas-game';
	doc.getElementsByClassName('level')[0].appendChild(canvas);

	/* This is called by the update function  and loops through all of the
	 * objects within your instance.entities array as defined in app.js and calls
	 * their update() methods. It will then call the update function for your
	 * player object. These update methods should focus purely on updating
	 * the data/properties related to  the object. Do your drawing in your
	 * render methods.
	 */
	function updateEntities(dt) {
		instance.entities.forEach(function EachEnemy(enemy) {
			enemy.update(dt);
		});
		player.update(dt);
	}

	/* This function is called by main (our game loop) and itself calls all
	 * of the functions which may need to update entity's data. Based on how
	 * you implement your collision detection (when two entities occupy the
	 * same space, for instance when your character should die), you may find
	 * the need to add an additional function call here. For now, we've left
	 * it commented out - you may or may not want to implement this
	 * functionality this way (you could just implement collision detection
	 * on the entities themselves within your app.js file).
	 */
	function update(dt) {
		updateEntities(dt);
		// checkCollisions();
	}

	/* This function is called by the render function and is called on each game
	 * tick. It's purpose is to then call the render functions you have defined
	 * on your enemy and player entities within app.js
	 */
	function renderEntities() {
		/* Loop through all of the objects within the instance.entities array and call
		 * the render function you have defined.
		 */
		var i;
		for (i = 0; i < instance.entities.length; i++) {
			instance.entities[i].render(ctx);
		}

		player.render(ctx);
	}

	/* This function initially draws the "game level", it will then call
	 * the renderEntities function. Remember, this function is called every
	 * game tick (or loop of the game engine) because that's how games work -
	 * they are flipbooks creating the illusion of animation but in reality
	 * they are just drawing the entire screen over and over.
	 */
	function render() {
		/* This array holds the relative URL to the image used
		 * for that particular row of the game level.
		 */
		var rowImages = [
				'images/water-block.png', // Top row is water
				'images/stone-block.png', // Row 1 of 3 of stone
				'images/stone-block.png', // Row 2 of 3 of stone
				'images/stone-block.png', // Row 3 of 3 of stone
				'images/grass-block.png', // Row 1 of 2 of grass
				'images/grass-block.png' // Row 2 of 2 of grass
			],
			numRows = 6,
			numCols = 5,
			row, col;

		//  Clear the entire canvas
		ctx.clearRect(0, 0, canvas.width, canvas.height);

		/* Loop through the number of rows and columns we've defined above
		 * and, using the rowImages array, draw the correct image for that
		 * portion of the "grid"
		 */
		for (row = 0; row < numRows; row++) {
			for (col = 0; col < numCols; col++) {
				/* The drawImage function of the canvas' context element
				 * requires 3 parameters: the image to draw, the x coordinate
				 * to start drawing and the y coordinate to start drawing.
				 * We're using our Resources helpers to refer to our images
				 * so that we get the benefits of caching these images, since
				 * we're using them over and over.
				 */
				ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);
			}
		}

		renderEntities();
	}

	/* This function serves as the kickoff point for the game loop itself
	 * and handles properly calling the update and render methods.
	 */
	function main() {
		if (running) {
			/* Get our time delta information which is required if your game
			 * requires smooth animation. Because everyone's computer processes
			 * instructions at different speeds we need a constant value that
			 * would be the same for everyone (regardless of how fast their
			 * computer is) - hurray time!
			 */
			var now = Date.now(),
				dt = (now - lastTime) / 1000.0;

			/* Call our update/render functions, pass along the time delta to
			 * our update function since it may be used for smooth animation.
			 */
			update(dt);
			render();

			/* Set our lastTime variable which is used to determine the time delta
			 * for the next time this function is called.
			 */
			lastTime = now;

			/* Use the browser's requestAnimationFrame function to call this
			 * function again as soon as the browser is able to draw another frame.
			 */
			win.requestAnimationFrame(main);
		}
	}

	/* This function does some initial setup that should only occur once,
	 * particularly setting the lastTime variable that is required for the
	 * game loop.
	 */
	function init() {
		instance.reset();
		running = true;
		lastTime = Date.now();
		main();
	}

	/* This function does nothing but it could have been a good place to
	 * handle game reset states - maybe a new game menu or a game over screen
	 * those sorts of things. It's only called once by the init() method.
	 */
	instance.reset = function reset() {
		running = false;
	};

	instance.pause = function pause() {
		running = false;
	};

	instance.preload = function preload() {
		/* Go ahead and load all of the images we know we're going to need to
		 * draw our game level. Then set init as the callback method, so that when
		 * all of these images are properly loaded our game will start.
		 */

		function locations(folder, format) {
			var resources = [
				'char-boy',
				'char-cat-girl',
				'char-horn-girl',
				'char-pink-girl',
				'char-princess-girl',
				'enemy-bug',
				'Gem Blue',
				'Gem Green',
				'Gem Orange',
				'grass-block',
				'Heart',
				'Key',
				'Rock',
				'Selector',
				'Star',
				'stone-block',
				'water-block'
			];
			return resources.map(function resourceMap(el) {
				return folder + el + '.' + format;
			});
		}
		Resources.load(locations('images/', 'png'));

		if (Resources.isReady()) {
			init();
		} else {
			Resources.onReady(init);
		}
	};

	/* Assign the canvas' context object to the global variable (the window
	 * object when run in a browser) so that developer's can use it more easily
	 * from within their app.js files.
	 */
	global.ctx = ctx;

	return instance;
})(this);

'use strict';
/**
* @description Model Singleton used for storing state data
* @constructor
*/
var Model = (function Model() {
	var data = {};
	var instance = function instance() {};

	/**
	 * @description Sets a value to a key
	 * @param {string} key - The property to store the value under
	 * @param {number} value - The value of the key
	 * @returns {*} The value of the key
	 */
	instance.set = function set(key, value) {
		data[key] = value;
		return value;
	};

	/**
	 * @description Returns the value set to the key
	 * @returns {*} The value of the key
	 */
	instance.get = function get(key) {
		return data[key];
	};

	return instance;
})();

'use strict';
/**
* @description A Timer class that updates manually using with delta time
* @constructor
*/
var Timer = function Timer(intervals, delay) {
	this.intervals = intervals;
	this.delay = delay;
	this.running = false;
	this.listeners = {};
	this.time = 0;
	this.laps = 0;
};

(function Prototype() {
	/**
	 * @description Resets the timer and flags it as running
	 */
	this.start = function start() {
		this.running = true;
		this.time = this.delay;
		this.laps = this.intervals;
	};

	/**
	 * @description Uses the delta time to manually update the timer
	 * @param {number} delta - Time since last update
	 */
	this.update = function update(delta) {
		if (this.running) {
			this.time = Math.max(0, this.time - delta);
			if (this.time === 0) {
				this.laps -= 1;
				if (this.laps <= 0) {
					this.running = false;
					this.dispatch('COMPLETE');
				}else {
					this.time = this.delay;
					this.dispatch('UPDATE');
				}
			}
		}
	};

	/**
	 * @description Adds a listener for the specified event
	 * @param {string} event - The event to listen for
	 * @param {function} listener - The callback function
	 */
	this.on = function on(event, listener) {
		if (!this.listeners.hasOwnProperty(event)) {
			this.listeners[event] = [];
		}
		this.listeners[event].push(listener);
	};

	/**
	 * @description Attempts to invoke a callback method for the given event
	 * @param {string} event - The event to dispatch
	 */
	this.dispatch = function dispatch(event) {
		var i;
		var list;
		if (this.listeners.hasOwnProperty(event)) {
			list = this.listeners[event];
			for (i = 0; i < list.length; i++) {
				list[i](this);
			}
		}
	};
}).call(Timer.prototype);

'use strict';
/**
* @description Grid Singleton used for positioning things on a Grid
* @constructor
*/
var Grid = (function Grid() {
	var instance = function instance() {};

	instance.cellWidth = 101;
	instance.cellHeight = 83;
	instance.columns = 5;
	instance.rows = 6;
	instance.offsetY = 50;

	/**
	 * @description Determines the x location based on the column
	 * @param {int} column - The column
	 * @returns {number} The screen x position
	 */
	instance.getXFromColumn = function getXFromColumn(column) {
		var col = Math.max(0, Math.min(column, instance.columns - 1));
		return col * instance.cellWidth;
	};

	/**
	 * @description Determines the y location based on the row
	 * @param {int} row - The row
	 * @returns {number} The screen y position
	 */
	instance.getYFromRow = function getYFromRow(row) {
		row = Math.max(0, Math.min(row, instance.rows - 1));
		return instance.offsetY + row * instance.cellHeight;
	};

	return instance;
})();

'use strict';
/**
* @description Handles level creation
* @constructor
*/
var Level = function Level() {
	this.reset();
};

(function Prototype() {
	/**
	 * @description Reset's level variables to original values
	 */
	this.reset = function reset() {
		this.level = Model.set('level', 0);
		this.lastLevel = 7;
		Model.set('level_total_time', 15);
		Model.set('level_complete', false);
	};

	/**
	 * @description Advances the current level by one
	 */
	this.next = function next() {
		this.level = Model.set('level', this.level + 1);
	};

	/**
	 * @description Creates all the entities for the current level
	 */
	this.addEntities = function addEntities() {
		var data = this.levelData();
		var i;
		Engine.entities = [];

		for (i = 0; i < data.length; i++) {
			if (data[i].hasOwnProperty('t')) {
				if (data[i].t === 'key') {
					Engine.entities.push(new Key(data[i].r, data[i].c));
				}else if (data[i].t === 'water') {
					Engine.entities.push(new Water(data[i].r, data[i].c));
				}
			}else {
				Engine.entities.push(new Enemy(data[i].r, data[i].c, data[i].s));
			}
		}
	};

	/**
	 * @description Returns the JSON entities for the given level
	 * @returns {array}
	 */
	this.levelData = function levelData() {
		//  Formatted so it's easier to see the levels (not following Udacity JS standards)
		//  jscs:disable
		if (this.level === 0) {
			return [
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 1) {
			return [
			{r: 3, c: 0, s: 200}, {r: 3, c: 2, s: 200}, {r: 3, c: 4, s: 200},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 2) {
			return [
			{r: 1, c: 0, s: -100}, {r: 1, c: 1, s: -100}, {r: 1, c: 3, s: -100}, {r: 1, c: 4, s: -100},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 3) {
			return [
			{r: 2, c: 0, s: 500}, {r: 2, c: 4, s: 600},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 4) {
			return [
			{r: 1, c: 0, s: -100}, {r: 1, c: 1, s: -100}, {r: 1, c: 3, s: -100}, {r: 1, c: 4, s: -100},
			{r: 3, c: 0, s: 200}, {r: 3, c: 2, s: 200}, {r: 3, c: 4, s: 200},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 5) {
			return [
			{r: 2, c: 0, s: 500}, {r: 2, c: 4, s: 600},
			{r: 3, c: 0, s: 200}, {r: 3, c: 2, s: 200}, {r: 3, c: 4, s: 200},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}else if (this.level === 6) {
			return [
			{r: 1, c: 0, s: -100}, {r: 1, c: 1, s: -100}, {r: 1, c: 3, s: -100}, {r: 1, c: 4, s: -100},
			{r: 2, c: 0, s: 500}, {r: 2, c: 4, s: 600},
			{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
			];
		}
		//  jscs:disable
		return [
		{r: 1, c: 0, s: -100}, {r: 1, c: 1, s: -100}, {r: 1, c: 3, s: -100}, {r: 1, c: 4, s: -100},
		{r: 2, c: 0, s: 500}, {r: 2, c: 4, s: 600},
		{r: 3, c: 0, s: 200}, {r: 3, c: 2, s: 200}, {r: 3, c: 4, s: 200},
		{r: 0, c: 0, t: 'water'}, {r: 0, c: 1, t: 'water'}, {r: 0, c: 2, t: 'key'}, {r: 0, c: 3, t: 'water'}, {r: 0, c: 4, t: 'water'}
		];
	};
}).call(Level.prototype);

'use strict';
/**
 * @description Scene Singleton used for changing the scene view
 * @constructor
 */
var Scene = (function Scene() {
	var instance = function instance() {};
	var level = new Level();
	var onCharacterClicked = function onCharacterClicked(el) {
		var s = el.target.src;
		player.sprite = s.slice(s.indexOf('/images/') + 1, s.length);

		El.removeClass(El.getElements('selected-char'), 'selected-char');
		El.addClass(el.target, 'selected-char');
	};
	/**
	 * @description Shows the Character selection scene
	 */
	instance.startMenu = function startMenu() {
		var characters = document.getElementsByClassName('char');
		var i;

		for (i = 0; i < characters.length; i++) {
			characters[i].addEventListener('click', onCharacterClicked);
		}

		Engine.reset();

		El.show('char_select');
		El.hide('level');
		El.hide('gameover');
		El.hide('gamewin');
		scene = 'char_select';
	};

	/**
	 * @description Shows the Game scene
	 */
	instance.startGame = function startGame(reset) {
		reset = reset || false;

		if (reset) {
			level.reset();
		} else {
			Model.set('level_complete', false);
		}

		Engine.preload();
		player.respawn();

		level.addEntities();
		Engine.entities.push(ui);
		ui.start();

		El.show('level');
		El.hide('char_select');
		El.hide('gameover');
		El.hide('gamewin');
		scene = 'level';
	};

	/**
	 * @description Shows the Game Over popup
	 */
	instance.endGame = function endGame() {
		El.show('gameover');
		Engine.pause();
	};

	/**
	 * @description Shows the Game Win popup
	 */
	instance.winGame = function winGame() {
		El.show('gamewin');
		Engine.pause();
	};

	/**
	 * @description The player picked up the key. Show star explosion and advance level after timeout
	 */
	instance.levelComplete = function levelComplete() {
		Model.set('level_complete', true);
		Engine.entities.push(new Explosion(0, 2));
		setTimeout(instance.nextLevel, 1500);
	};

	/**
	 * @description Advance to the next level or end the game if no more levels
	 */
	instance.nextLevel = function nextLevel() {
		level.next();

		if (level.level > level.lastLevel) {
			instance.winGame();
		} else {
			instance.startGame();
		}
	};

	return instance;
})();

'use strict';
/**
* @description A sensor used as a collision box that can be rendered to the screen for testing
* @constructor
* @param {number} x - The x location
* @param {number} y - The y location
* @param {number} width - How long the sensor is
* @param {number} height - How tall the sensor is
* @param {number} offsetX - The offset in the x direction
* @param {number} offsetY - The offset in the y direction
*/
var Sensor = function Sensor(x, y, width, height, offsetX, offsetY) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.offsetX = offsetX;
	this.offsetY = offsetY;
	this.debug = false;
};

(function Prototype() {
	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		if (this.debug) {
			ctx.beginPath();
			ctx.strokeStyle = 'red';
			ctx.rect(this.x, this.y, this.width, this.height);
			ctx.stroke();
		}
	};

	/**
	 * @description Updates the sensor's position
	 * @param {int} x - The x location
	 * @param {int} y - The y location
	 */
	this.position = function position(x, y) {
		this.x = x + this.offsetX;
		this.y = y + this.offsetY;
	};
}).call(Sensor.prototype);

'use strict';
/**
* @description A component that renders the owners sprite according to position, alpha and direction
* @constructor
*/
var Render = function Render(owner) {
	this.owner = owner;
};

(function Prototype() {
	var p = {x: 0, y: 0};
	/**
	  * @description Renders the owner's sprite
	  * @param {context} ctx - The canvas's context
	  */
	this.render = function render(ctx) {
		var flipped = this.owner.flipped ? -1 : 1;
		var pos = this.getPosition();
		ctx.save();
		ctx.scale(flipped, 1);
		ctx.globalAlpha = this.owner.alpha || 1;
		ctx.drawImage(Resources.get(this.owner.sprite), pos.x, pos.y, 101, 171);
		ctx.restore();
	};

	/**
	  * @description Returns the formatted position
	  */
	this.getPosition = function getPosition() {
		var flipped = this.owner.flipped ? -1 : 1;
		p.x = (this.owner.x + this.owner.offsetX) * flipped;
		p.x += (flipped === 1 ? 0 : -101);
		p.y = this.owner.y + this.owner.offsetY;
		return p;
	};
}).call(Render.prototype);

'use strict';
/**
* @description The ingame information display
* @constructor
*/
var UI = function UI() {
	this.keys = 0;
	this.levelTime = 0;
	this.time = 0;
};

(function Prototype() {
	/**
	 * @description Resets the level information and starts the game timer
	 */
	this.start = function start() {
		this.keys = Model.get('level');
		this.levelTime = Model.get('level_total_time');

		this.levelTimer = new Timer(1, this.levelTime);
		this.levelTimer.on('COMPLETE', this.onTimerComplete);
		this.levelTimer.start();
	};

	/**
	 * @description The level timer has completed
	 */
	this.onTimerComplete = function onTimerComplete() {
		if (!Model.get('level_complete')) {
			Scene.endGame();
		}
	};

	/**
	 * @description Formated string of time left (expects >0 && <60 seconds)
	 * @returns {string} Seconds left on time
	 */
	this.formattedTime = function formattedTime() {
		var time = Math.round(this.levelTimer.time);
		return '00:' + (time > 9 ? time : '0' + time);
	};

	/**
	 * @description Renders text to the screen
	 * @param {context} ctx - The canvas's context
	 * @param {string} string - The string to display
	 * @param {number} x - The x location
	 * @param {number} y - The y location
	 * @param {string} align - The canvas's context
	 */
	this.text = function text(ctx, string, x, y, align) {
		ctx.save();
		ctx.font = '30px Comic Sans MS';
		if (align === 'left' || align === 'right' || align === 'center') {
			ctx.textAlign = align;
		}
		ctx.fillText(string, x, y);
		ctx.restore();
	};

	/**
	 * @description Updates the timer and key information
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		if (!Model.get('level_complete')) {
			this.keys = Model.get('level');
			this.levelTimer.update(dt);
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.text(ctx, 'Keys: x' + this.keys, 0, 30);
		this.text(ctx, 'Time: ' + this.formattedTime(), Engine.width, 30, 'right');
	};
}).call(UI.prototype);

'use strict';
/**
* @description Key entity
* @constructor
* @param {int} row - The initial row
* @param {int} col - The initial column
*/
var Key = function Key(row, col) {
	this.entity = new Entity(this,
		Grid.getXFromColumn(col),
		Grid.getYFromRow(row),
		'images/Key.png',
		0,
		-(171 - 138) - Grid.offsetY);
	this.sensor = new Sensor(0, 0, 50, 30, 25, 25);
	this.renderer = new Render(this);
};

(function Prototype() {
	/**
	 * @description Checks if this entity is colliding with the player
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.sensor.position(this.x, this.y);
		if (player && player.isAlive && this.isAlive) {
			if (Collision.isColliding(this.sensor, player.sensor)) {
				this.isAlive = false;
				player.hit('key');
			}
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.renderer.render(ctx);
		this.sensor.render(ctx);
	};
}).call(Key.prototype);

'use strict';
/**
* @description Water entity
* @constructor
* @param {int} row - The initial row
* @param {int} col - The initial column
*/
var Water = function Water(row, col) {
	this.entity = new Entity(this,
		Grid.getXFromColumn(col),
		Grid.getYFromRow(row),
		'images/Key.png',
		0,
		-(171 - 138) - Grid.offsetY);
	this.sensor = new Sensor(0, 0, 50, 30, 25, 25);
};

(function Prototype() {
	/**
	 * @description Checks if this entity is colliding with the player
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.sensor.position(this.x, this.y);

		if (player && player.isAlive) {
			if (Collision.isColliding(this.sensor, player.sensor)) {
				player.hit('water');
			}
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.sensor.render(ctx);
	};
}).call(Water.prototype);

'use strict';
/**
 * @description Enemy entity
 * @constructor
 * @param {int} row - The initial row
 * @param {int} col - The initial column
 * @param {number} speed - The initial speed
 */
var Enemy = function Enemy(row, col, speed) {
	this.entity = new Entity(this,
		Grid.getXFromColumn(col),
		Grid.getYFromRow(row),
		'images/enemy-bug.png',
		0, -(171 - 138) - Grid.offsetY);
	this.row = row;
	this.speed = speed;
	this.flipped = speed < 0;
	this.sensor = new Sensor(0, 0, 50, 50, 25, 12);
	this.renderer = new Render(this);
};

(function Prototype() {
	/**
	 * @description Checks if this entity is colliding with the player and keeps target on screen by wrapping x location
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.x += dt * this.speed;

		//  Wrap
		if (this.x > (Grid.columns * Grid.cellWidth) + Grid.cellWidth) {
			this.x = Grid.getXFromColumn(0) - Grid.cellWidth;
		} else if (this.x < -Grid.cellWidth) {
			this.x = (Grid.columns * Grid.cellWidth) + Grid.cellWidth;
		}

		this.sensor.position(this.x, this.y);
		if (player && player.isAlive) {
			if (Collision.isColliding(this.sensor, player.sensor)) {
				player.hit('enemy');
			}
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.renderer.render(ctx);
		this.sensor.render(ctx);
	};
}).call(Enemy.prototype);

'use strict';
/**
* @description Player entity
* @constructor
*/
var Player = function Player() {
	this.entity = new Entity(this,
		0,
		0,
		'images/char-boy.png',
		0,
		-(171 - 138) - Grid.offsetY);
	this.isAlive = false;
	this.alpha = 0;
	this.sensor = new Sensor(0, 0, 50, 30, 25, 25);
	this.renderer = new Render(this);
	this.blinkTimer = new Timer(5, 0.2);

	var ref = this;

	var onBlinkTimerComplete = function onBlinkTimerComplete() {
		ref.alpha = 1;
		ref.isAlive = true;
	};

	var onBlinkTimerUpdate = function onBlinkTimerUpdate() {
		ref.alpha = (ref.alpha === 0.4 ? 1 : 0.4);
	};

	var onKeyUp = function onKeyUp(e) {
		ref.handleInput(e);
	};

	this.blinkTimer.on('COMPLETE', onBlinkTimerComplete);
	this.blinkTimer.on('UPDATE', onBlinkTimerUpdate);
	document.addEventListener('keyup', onKeyUp);

	this.respawn();
};

(function Prototype() {
	var inputMap = {
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down'
	};

	var inputResponseMap = {
		left: {axis: 'x', dir: -1},
		up: {axis: 'y', dir: -1},
		right: {axis: 'x', dir: 1},
		down: {axis: 'y', dir: 1}
	};

	/**
	 * @description Resets the player to the initial position
	 */
	this.respawn = function respawn() {
		this.sensor.x = this.x = Grid.getXFromColumn(2);
		this.sensor.y = this.y = Grid.getYFromRow(5);
		this.isAlive = false;
		this.alpha = 0.4;
		this.blinkTimer.start();
	};

	/**
	 * @description A entity has hit the player
	 * @param {string} invoker - Type of object that hit the player
	 */
	this.hit = function hit(invoker) {
		if (invoker === 'water' || invoker === 'enemy') {
			this.respawn();
		}else if (invoker === 'key') {
			Scene.levelComplete();
		}
	};

	/**
	 * @description Gets the position on the grid based on player's input
	 * @param {string} axis - The x or y axis
	 * @param {input} dir - The positive or negative direction
	 * @returns {number} The final position
	 */
	this.getMovement = function getMovement(axis, dir) {
		var v;

		if (axis === 'x') {
			v = Math.floor(this.x / Grid.cellWidth) + dir;
			return Grid.getXFromColumn(v);
		}

		v = Math.floor(this.y / Grid.cellHeight) + dir;
		return Grid.getYFromRow(v);
	};

	/**
	 * @description Changes the player position based on input
	 * @param {event} e - The event that occured
	 */
	this.handleInput = function handleInput(e) {
		var input = inputMap[e.keyCode];
		if (input && this.isAlive === true && !Model.get('level_complete')) {
			var map = inputResponseMap[input];

			//  Movement
			if (map.hasOwnProperty('axis')) {
				this[map.axis] = this.getMovement(map.axis, map.dir);
			}
		}
	};

	/**
	 * @description Updates the players timer and sensor
	 * @param {number} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.sensor.position(this.x, this.y);
		if (!this.isAlive) {
			this.blinkTimer.update(dt);
		}
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.renderer.render(ctx);
		this.sensor.render(ctx);
	};
}).call(Player.prototype);

'use strict';
/**
* @description Star entity
* @constructor
* @param {int} row - The initial row
* @param {int} col - The initial column
*/
var Star = function Star(row, col) {
	this.entity = new Entity(this,
		Grid.getXFromColumn(col),
		Grid.getYFromRow(row),
		'images/Star.png',
		0,
		-(171 - 138) - Grid.offsetY);
	this.renderer = new Render(this);
	this.speed = 500;
	this.angle = Math.round(Math.random() * 180) * Math.PI / 180;
};

(function Prototype() {
	/**
	 * @description Moves the star in the direction of the angle and lowers opacity
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		this.x += this.speed * Math.cos(this.angle) * dt;
		this.y += this.speed * Math.sin(this.angle) * dt;
		this.alpha = Math.max(0.01, this.alpha - 1 * dt);
	};

	/**
	 * @description Renders this entity to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		this.renderer.render(ctx);
	};
}).call(Star.prototype);

'use strict';
/**
 * @description Key entity
 * @constructor
 * @param {int} row - The initial row
 * @param {int} col - The initial column
 */
var Explosion = function Explosion(row, col) {
	this.stars = [];
	this.addStars(row, col, 10);
};

(function Prototype() {
	/**
	 * @description Adds the stars
	 * @param {int} row - The y location
	 * @param {int} col - The x location
	 * @param {int} total - Amount of stars
	 */
	this.addStars = function addStars(row, col, total) {
		var i;
		for (i = 0; i < total; i++) {
			this.stars.push(new Star(row, col));
		}
	};

	/**
	 * @description Moves all the stars
	 * @param {int} dt - Time since last update
	 */
	this.update = function update(dt) {
		var total = this.stars.length;
		var i;
		if (total > 0) {
			if (this.stars[0].alpha <= 0.01) {
				this.stars = [];
			} else {
				for (i = 0; i < total; i++) {
					this.stars[i].update(dt);
				}
			}
		}
	};
	/**
	 * @description Renders the stars to the canvas
	 * @param {context} ctx - The canvas's context
	 */
	this.render = function render(ctx) {
		var total = this.stars.length;
		var i;
		for (i = 0; i < total; i++) {
			this.stars[i].render(ctx);
		}
	};
}).call(Explosion.prototype);

'use strict';
var player = new Player();
var ui = new UI();
var scene = '';
var App = (function App() {
	var onPlayClicked = function onPlayClicked() {
		Scene.startGame(true);
	};
	var onReplayClicked = function onReplayClicked() {
		Scene.startGame();
	};
	var onMenuClicked = function onMenuClicked() {
		Scene.startMenu();
	};

	El.addListener(El.getElements('btn-play')[0], 'click', onPlayClicked);
	El.addListener(El.getElements('btn-replay')[0], 'click', onReplayClicked);
	El.addListener(El.getElements('btn-menu'), 'click', onMenuClicked);

	//	Default show the start menu
	Scene.startMenu();
	//	Scene.startGame();
})();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsLmpzIiwiZW50aXR5LmpzIiwicmVzb3VyY2VzLmpzIiwiY29sbGlzaW9uLmpzIiwiZW5naW5lLmpzIiwibW9kZWwuanMiLCJ0aW1lci5qcyIsImdyaWQuanMiLCJsZXZlbC5qcyIsInNjZW5lLmpzIiwic2Vuc29yLmpzIiwicmVuZGVyLmpzIiwidWkuanMiLCJrZXkuanMiLCJ3YXRlci5qcyIsImVuZW15LmpzIiwicGxheWVyLmpzIiwic3Rhci5qcyIsImV4cGxvc2lvbi5qcyIsImFwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYXBwLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQGRlc2NyaXB0aW9uIEVsIFNpbmdsZXRvbiB1c2VkIGZvciBtYW5pcHVsYXRpbmcgRE9NIGVsZW1lbnRzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEVsID0gKGZ1bmN0aW9uIEVsKCkge1xuXHR2YXIgaW5zdGFuY2UgPSBmdW5jdGlvbiBpbnN0YW5jZSgpIHt9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyB0aGUgY2xhc3NOYW1lIGZyb20gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuXHQgKiBAcGFyYW0ge2FycmF5fSBlbGVtZW50cyAtIEFycmF5IG9mIERPTSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gQ2xhc3MgdG8gcmVtb3ZlXG5cdCAqL1xuXHRpbnN0YW5jZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnRzLCBjbGFzc05hbWUpIHtcblx0XHR2YXIgaSwgYztcblx0XHRpZiAoZWxlbWVudHMpIHtcblx0XHRcdGlmICghdGhpcy5pc0hUTUxDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuXHRcdFx0XHRlbGVtZW50cyA9IFtlbGVtZW50c107XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0YyA9IGVsZW1lbnRzW2ldLmNsYXNzTmFtZS5yZXBsYWNlKCcgJyArIGNsYXNzTmFtZSwgJycpO1xuXHRcdFx0XHRlbGVtZW50c1tpXS5jbGFzc05hbWUgPSBjO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIEFkZHMgdGhlIGNsYXNzTmFtZSBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5XG5cdCAqIEBwYXJhbSB7YXJyYXl9IGVsZW1lbnRzIC0gQXJyYXkgb2YgRE9NIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgLSBDbGFzcyB0byBhZGRcblx0ICovXG5cdGluc3RhbmNlLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudHMsIGNsYXNzTmFtZSkge1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKGVsZW1lbnRzKSB7XG5cdFx0XHRpZiAoIXRoaXMuaXNIVE1MQ29sbGVjdGlvbihlbGVtZW50cykpIHtcblx0XHRcdFx0ZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChlbGVtZW50c1tpXS5jbGFzc05hbWUuaW5kZXhPZignICcgKyBjbGFzc05hbWUpIDwgMCkge1xuXHRcdFx0XHRcdGVsZW1lbnRzW2ldLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBBZGRzIGEgbGlzdGVuZXIgb24gdGhlIGVsZW1lbnRcblx0ICogQHBhcmFtIHthcnJheX0gZWxlbWVudHMgLSBBcnJheSBvZiBET00gZWxlbWVudHNcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gRXZlbnQgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgY2FwdHVyZWRcblx0ICovXG5cdGluc3RhbmNlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWxlbWVudHMsIGV2ZW50LCBjYWxsYmFjaykge1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKGVsZW1lbnRzKSB7XG5cdFx0XHRpZiAoZWxlbWVudHMubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGVsZW1lbnRzW2ldLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHRoZSBoaWRkZW4gY2xhc3MgZnJvbSB0aGUgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gY2xhc3NOYW1lIG9yICNJRFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciAtIFRoZSBlbGVtZW50cyB0byBmaW5kXG5cdCAqL1xuXHRpbnN0YW5jZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhpZGVudGlmaWVyKSB7XG5cdFx0dGhpcy5yZW1vdmVDbGFzcyh0aGlzLmdldEVsZW1lbnRzKGlkZW50aWZpZXIpLCAnaGlkZGVuJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBBZGRzIHRoZSBoaWRkZW4gY2xhc3Mgb24gdGhlIGVsZW1lbnRzIHdpdGggdGhlIGdpdmVuIGNsYXNzTmFtZSBvciAjSURcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgLSBUaGUgZWxlbWVudHMgdG8gZmluZFxuXHQgKi9cblx0aW5zdGFuY2UuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoaWRlbnRpZmllcikge1xuXHRcdHRoaXMuYWRkQ2xhc3ModGhpcy5nZXRFbGVtZW50cyhpZGVudGlmaWVyKSwgJ2hpZGRlbicpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gRmluZHMgYWxsIHRoZSBlbGVtZW50cyB3aXRoIHRoZSBjbGFzc05hbWUgb3IgI0lEXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIC0gVGhlIGVsZW1lbnRzIHRvIGZpbmRcblx0ICovXG5cdGluc3RhbmNlLmdldEVsZW1lbnRzID0gZnVuY3Rpb24gZ2V0RWxlbWVudHMoaWRlbnRpZmllcikge1xuXHRcdGlmICh0aGlzLmlzU3RyaW5nKGlkZW50aWZpZXIpKSB7XG5cdFx0XHRpZiAoaWRlbnRpZmllci5pbmRleE9mKCcjJykgIT09IC0xKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZGVudGlmaWVyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGlkZW50aWZpZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiB0aGUgdmFyaWFibGUgaXMgYSBzdHJpbmdcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhcmlhYmxlIC0gVGhlIHZhcmlhYmxlIHRvIGNoZWNrXG5cdCAqL1xuXHRpbnN0YW5jZS5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhcmlhYmxlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlKHZhcmlhYmxlLCAnW29iamVjdCBTdHJpbmddJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgdGhlIHZhcmlhYmxlIGlzIGEgSFRNTENvbGxlY3Rpb25cblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhcmlhYmxlIC0gVGhlIHZhcmlhYmxlIHRvIGNoZWNrXG5cdCAqL1xuXHRpbnN0YW5jZS5pc0hUTUxDb2xsZWN0aW9uID0gZnVuY3Rpb24gaXNIVE1MQ29sbGVjdGlvbih2YXJpYWJsZSkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZSh2YXJpYWJsZSwgJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgdGhlIHZhcmlhYmxlIGlzIHRoZSB0eXBlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YXJpYWJsZSAtIFRoZSB2YXJpYWJsZSB0byBjaGVja1xuXHQgKi9cblx0aW5zdGFuY2UuaXNUeXBlID0gZnVuY3Rpb24gaXNUeXBlKHZhcmlhYmxlLCB0eXBlKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YXJpYWJsZSkgPT09IHR5cGU7XG5cdH07XG5cblx0cmV0dXJuIGluc3RhbmNlO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gRW50aXR5IHNldHMgYWxsIGRlZmF1bHQgdmFyaWFibGVzIHRvIHRoZSBvd25lclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtvYmplY3R9IG93bmVyIC0gVGhlIGluaXRpYWwgcm93XG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGluaXRpYWwgeCBsb2NhdGlvblxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBpbml0aWFsIHkgbG9jYXRpb25cbiogQHBhcmFtIHtzdHJpbmd9IHNwcml0ZSAtIFRoZSBkaXNwbGF5IHNwcml0ZVxuKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFRoZSBpbml0aWFsIHggb2Zmc2V0XG4qIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0gVGhlIGluaXRpYWwgeSBvZmZzZXRcbiovXG52YXIgRW50aXR5ID0gZnVuY3Rpb24gRW50aXR5KG93bmVyLCB4LCB5LCBzcHJpdGUsIG9mZnNldFgsIG9mZnNldFkpIHtcblx0dGhpcy5vd25lciA9IG93bmVyO1xuXHRvd25lci54ID0geDtcblx0b3duZXIueSA9IHk7XG5cdG93bmVyLnNwcml0ZSA9IHNwcml0ZSB8fCBudWxsO1xuXHRvd25lci5vZmZzZXRYID0gb2Zmc2V0WCB8fCAwO1xuXHRvd25lci5vZmZzZXRZID0gb2Zmc2V0WSB8fCAwO1xuXHRvd25lci5mbGlwcGVkID0gZmFsc2U7XG5cdG93bmVyLmFscGhhID0gMTtcblx0b3duZXIuaXNBbGl2ZSA9IHRydWU7XG5cdG93bmVyLnNwZWVkID0gMDtcblx0b3duZXIuYW5nbGUgPSAwO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIFJlc291cmNlcy5qc1xuICogVGhpcyBpcyBzaW1wbGUgYW4gaW1hZ2UgbG9hZGluZyB1dGlsaXR5LiBJdCBlYXNlcyB0aGUgcHJvY2VzcyBvZiBsb2FkaW5nXG4gKiBpbWFnZSBmaWxlcyBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgd2l0aGluIHlvdXIgZ2FtZS4gSXQgYWxzbyBpbmNsdWRlc1xuICogYSBzaW1wbGUgXCJjYWNoaW5nXCIgbGF5ZXIgc28gaXQgd2lsbCByZXVzZSBjYWNoZWQgaW1hZ2VzIGlmIHlvdSBhdHRlbXB0XG4gKiB0byBsb2FkIHRoZSBzYW1lIGltYWdlIG11bHRpcGxlIHRpbWVzLlxuICovXG4oZnVuY3Rpb24gUmVzb3VyY2VzKCkge1xuXHR2YXIgcmVzb3VyY2VDYWNoZSA9IHt9O1xuXHR2YXIgbG9hZGluZyA9IFtdO1xuXHR2YXIgcmVhZHlDYWxsYmFja3MgPSBbXTtcblxuXHQvKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgYWxsIG9mIHRoZSBpbWFnZXMgdGhhdCBoYXZlIGJlZW4gcmVxdWVzdGVkXG5cdCAgICogZm9yIGxvYWRpbmcgaGF2ZSBpbiBmYWN0IGJlZW4gY29tcGxldGVkIGxvYWRlZC5cblx0ICAgKi9cblx0ZnVuY3Rpb24gaXNSZWFkeSgpIHtcblx0XHR2YXIgcmVhZHkgPSB0cnVlO1xuXHRcdGZvciAodmFyIGsgaW4gcmVzb3VyY2VDYWNoZSkge1xuXHRcdFx0aWYgKHJlc291cmNlQ2FjaGUuaGFzT3duUHJvcGVydHkoaykgJiZcblx0XHRcdCFyZXNvdXJjZUNhY2hlW2tdKSB7XG5cdFx0XHRcdHJlYWR5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZWFkeTtcblx0fVxuXG5cdC8qIFRoaXMgaXMgb3VyIHByaXZhdGUgaW1hZ2UgbG9hZGVyIGZ1bmN0aW9uLCBpdCBpc1xuXHQgICAqIGNhbGxlZCBieSB0aGUgcHVibGljIGltYWdlIGxvYWRlciBmdW5jdGlvbi5cblx0ICAgKi9cblx0ZnVuY3Rpb24gX2xvYWQodXJsKSB7XG5cdFx0aWYgKCFyZXNvdXJjZUNhY2hlW3VybF0pIHtcblx0XHRcdC8qIFRoaXMgVVJMIGhhcyBub3QgYmVlbiBwcmV2aW91c2x5IGxvYWRlZCBhbmQgaXMgbm90IHByZXNlbnRcblx0XHRcdCAgICAgICAqIHdpdGhpbiBvdXIgY2FjaGU7IHdlJ2xsIG5lZWQgdG8gbG9hZCB0aGlzIGltYWdlLlxuXHRcdFx0ICAgICAgICovXG5cdFx0XHR2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cdFx0XHRpbWcub25sb2FkID0gZnVuY3Rpb24gb25JbWFnZUxvYWQoKSB7XG5cdFx0XHRcdC8qIE9uY2Ugb3VyIGltYWdlIGhhcyBwcm9wZXJseSBsb2FkZWQsIGFkZCBpdCB0byBvdXIgY2FjaGVcblx0XHRcdFx0ICAgICAgICAgKiBzbyB0aGF0IHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoaXMgaW1hZ2UgaWYgdGhlIGRldmVsb3BlclxuXHRcdFx0XHQgICAgICAgICAqIGF0dGVtcHRzIHRvIGxvYWQgdGhpcyBmaWxlIGluIHRoZSBmdXR1cmUuXG5cdFx0XHRcdCAgICAgICAgICovXG5cdFx0XHRcdHJlc291cmNlQ2FjaGVbdXJsXSA9IGltZztcblxuXHRcdFx0XHQvKiBPbmNlIHRoZSBpbWFnZSBpcyBhY3R1YWxseSBsb2FkZWQgYW5kIHByb3Blcmx5IGNhY2hlZCxcblx0XHRcdFx0ICAgICAgICAgKiBjYWxsIGFsbCBvZiB0aGUgb25SZWFkeSgpIGNhbGxiYWNrcyB3ZSBoYXZlIGRlZmluZWQuXG5cdFx0XHRcdCAgICAgICAgICovXG5cdFx0XHRcdGlmIChpc1JlYWR5KCkpIHtcblx0XHRcdFx0XHRyZWFkeUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIGNhbGxDYWxsYmFja3MoZnVuYykgeyBmdW5jKCk7IH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvKiBTZXQgdGhlIGluaXRpYWwgY2FjaGUgdmFsdWUgdG8gZmFsc2UsIHRoaXMgd2lsbCBjaGFuZ2Ugd2hlblxuXHRcdFx0ICAgICAgICogdGhlIGltYWdlJ3Mgb25sb2FkIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkLiBGaW5hbGx5LCBwb2ludFxuXHRcdFx0ICAgICAgICogdGhlIGltYWdlcyBzcmMgYXR0cmlidXRlIHRvIHRoZSBwYXNzZWQgaW4gVVJMLlxuXHRcdFx0ICAgICAgICovXG5cdFx0XHRyZXNvdXJjZUNhY2hlW3VybF0gPSBmYWxzZTtcblx0XHRcdGltZy5zcmMgPSB1cmw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiByZXNvdXJjZUNhY2hlW3VybF07XG5cdFx0fVxuXHR9XG5cblx0LyogVGhpcyBpcyB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSBpbWFnZSBsb2FkaW5nIGZ1bmN0aW9uLiBJdCBhY2NlcHRzXG5cdCAgICogYW4gYXJyYXkgb2Ygc3RyaW5ncyBwb2ludGluZyB0byBpbWFnZSBmaWxlcyBvciBhIHN0cmluZyBmb3IgYSBzaW5nbGVcblx0ICAgKiBpbWFnZS4gSXQgd2lsbCB0aGVuIGNhbGwgb3VyIHByaXZhdGUgaW1hZ2UgbG9hZGluZyBmdW5jdGlvbiBhY2NvcmRpbmdseS5cblx0ICAgKi9cblx0ZnVuY3Rpb24gbG9hZCh1cmxPckFycikge1xuXHRcdGlmICh1cmxPckFyciBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHQvKiBJZiB0aGUgZGV2ZWxvcGVyIHBhc3NlZCBpbiBhbiBhcnJheSBvZiBpbWFnZXNcblx0XHRcdCAgICAgICAqIGxvb3AgdGhyb3VnaCBlYWNoIHZhbHVlIGFuZCBjYWxsIG91ciBpbWFnZVxuXHRcdFx0ICAgICAgICogbG9hZGVyIG9uIHRoYXQgaW1hZ2UgZmlsZVxuXHRcdFx0ICAgICAgICovXG5cdFx0XHR1cmxPckFyci5mb3JFYWNoKGZ1bmN0aW9uIGxvYWRVUkwodXJsKSB7XG5cdFx0XHRcdF9sb2FkKHVybCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogVGhlIGRldmVsb3BlciBkaWQgbm90IHBhc3MgYW4gYXJyYXkgdG8gdGhpcyBmdW5jdGlvbixcblx0XHRcdCAgICAgICAqIGFzc3VtZSB0aGUgdmFsdWUgaXMgYSBzdHJpbmcgYW5kIGNhbGwgb3VyIGltYWdlIGxvYWRlclxuXHRcdFx0ICAgICAgICogZGlyZWN0bHkuXG5cdFx0XHQgICAgICAgKi9cblx0XHRcdF9sb2FkKHVybE9yQXJyKTtcblx0XHR9XG5cdH1cblxuXHQvKiBUaGlzIGlzIHVzZWQgYnkgZGV2ZWxvcGVyJ3MgdG8gZ3JhYiByZWZlcmVuY2VzIHRvIGltYWdlcyB0aGV5IGtub3dcblx0ICAgKiBoYXZlIGJlZW4gcHJldmlvdXNseSBsb2FkZWQuIElmIGFuIGltYWdlIGlzIGNhY2hlZCwgdGhpcyBmdW5jdGlvbnNcblx0ICAgKiB0aGUgc2FtZSBhcyBjYWxsaW5nIGxvYWQoKSBvbiB0aGF0IFVSTC5cblx0ICAgKi9cblx0ZnVuY3Rpb24gZ2V0KHVybCkge1xuXHRcdHJldHVybiByZXNvdXJjZUNhY2hlW3VybF07XG5cdH1cblxuXHQvKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkIGEgZnVuY3Rpb24gdG8gdGhlIGNhbGxiYWNrIHN0YWNrIHRoYXQgaXMgY2FsbGVkXG5cdCAgICogd2hlbiBhbGwgcmVxdWVzdGVkIGltYWdlcyBhcmUgcHJvcGVybHkgbG9hZGVkLlxuXHQgICAqL1xuXHRmdW5jdGlvbiBvblJlYWR5KGZ1bmMpIHtcblx0XHRyZWFkeUNhbGxiYWNrcy5wdXNoKGZ1bmMpO1xuXHR9XG5cblx0LyogVGhpcyBvYmplY3QgZGVmaW5lcyB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSBmdW5jdGlvbnMgYXZhaWxhYmxlIHRvXG5cdCAgICogZGV2ZWxvcGVycyBieSBjcmVhdGluZyBhIGdsb2JhbCBSZXNvdXJjZXMgb2JqZWN0LlxuXHQgICAqL1xuXHR3aW5kb3cuUmVzb3VyY2VzID0ge1xuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0Z2V0OiBnZXQsXG5cdFx0b25SZWFkeTogb25SZWFkeSxcblx0XHRpc1JlYWR5OiBpc1JlYWR5XG5cdH07XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ29sbGlzaW9uIFNpbmdsZXRvbiB1c2VkIGZvciBjaGVja2luZyBjb2xsaXNpb24gYmV0d2VlbiB0d28gc2Vuc29yc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb2xsaXNpb24gPSAoZnVuY3Rpb24gUHJvdG90eXBlKCkge1xuXHR2YXIgaW5zdGFuY2UgPSBmdW5jdGlvbiBpbnN0YW5jZSgpIHt9O1xuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFVzZXMgYm94IGNvbGxpc2lvbiB0byBjaGVjayBpZiB0d28gc2Vuc29ycyBhcmUgdG91Y2hpbmdcblx0ICogQHBhcmFtIHtTZW5vcn0gc2Vuc29yQSAtIEJvdW5kaW5nIHJlY3QgQVxuXHQgKiBAcGFyYW0ge1Nlbm9yfSBzZW5zb3JCIC0gQm91bmRpbmcgcmVjdCBCXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBiYXNlZCBvbiBzZW5zb3Igb3ZlcmxhcFxuXHQgKi9cblx0aW5zdGFuY2UuaXNDb2xsaWRpbmcgPSBmdW5jdGlvbiBpc0NvbGxpZGluZyhzZW5zb3JBLCBzZW5zb3JCKSB7XG5cdFx0cmV0dXJuIChzZW5zb3JBLnggPCBzZW5zb3JCLnggKyBzZW5zb3JCLndpZHRoICYmXG5cdFx0XHRzZW5zb3JBLnggKyBzZW5zb3JCLndpZHRoID4gc2Vuc29yQi54ICYmXG5cdFx0XHRzZW5zb3JBLnkgPCBzZW5zb3JCLnkgKyBzZW5zb3JCLmhlaWdodCAmJlxuXHRcdFx0c2Vuc29yQS5oZWlnaHQgKyBzZW5zb3JBLnkgPiBzZW5zb3JCLnkpO1xuXHR9O1xuXHRyZXR1cm4gaW5zdGFuY2U7XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogRW5naW5lLmpzXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgdGhlIGdhbWUgbG9vcCBmdW5jdGlvbmFsaXR5ICh1cGRhdGUgZW50aXRpZXMgYW5kIHJlbmRlciksXG4gKiBkcmF3cyB0aGUgaW5pdGlhbCBnYW1lIGJvYXJkIG9uIHRoZSBzY3JlZW4sIGFuZCB0aGVuIGNhbGxzIHRoZSB1cGRhdGUgYW5kXG4gKiByZW5kZXIgbWV0aG9kcyBvbiB5b3VyIHBsYXllciBhbmQgZW5lbXkgb2JqZWN0cyAoZGVmaW5lZCBpbiB5b3VyIGFwcC5qcykuXG4gKlxuICogQSBnYW1lIGVuZ2luZSB3b3JrcyBieSBkcmF3aW5nIHRoZSBlbnRpcmUgZ2FtZSBzY3JlZW4gb3ZlciBhbmQgb3Zlciwga2luZCBvZlxuICogbGlrZSBhIGZsaXBib29rIHlvdSBtYXkgaGF2ZSBjcmVhdGVkIGFzIGEga2lkLiBXaGVuIHlvdXIgcGxheWVyIG1vdmVzIGFjcm9zc1xuICogdGhlIHNjcmVlbiwgaXQgbWF5IGxvb2sgbGlrZSBqdXN0IHRoYXQgaW1hZ2UvY2hhcmFjdGVyIGlzIG1vdmluZyBvciBiZWluZ1xuICogZHJhd24gYnV0IHRoYXQgaXMgbm90IHRoZSBjYXNlLiBXaGF0J3MgcmVhbGx5IGhhcHBlbmluZyBpcyB0aGUgZW50aXJlIFwic2NlbmVcIlxuICogaXMgYmVpbmcgZHJhd24gb3ZlciBhbmQgb3ZlciwgcHJlc2VudGluZyB0aGUgaWxsdXNpb24gb2YgYW5pbWF0aW9uLlxuICpcbiAqIFRoaXMgZW5naW5lIGlzIGF2YWlsYWJsZSBnbG9iYWxseSB2aWEgdGhlIEVuZ2luZSB2YXJpYWJsZSBhbmQgaXQgYWxzbyBtYWtlc1xuICogdGhlIGNhbnZhcycgY29udGV4dCAoY3R4KSBvYmplY3QgZ2xvYmFsbHkgYXZhaWxhYmxlIHRvIG1ha2Ugd3JpdGluZyBhcHAuanNcbiAqIGEgbGl0dGxlIHNpbXBsZXIgdG8gd29yayB3aXRoLlxuICovXG5cbnZhciBFbmdpbmUgPSAoZnVuY3Rpb24gRW5naW5lKGdsb2JhbCkge1xuXHQvKiBQcmVkZWZpbmUgdGhlIHZhcmlhYmxlcyB3ZSdsbCBiZSB1c2luZyB3aXRoaW4gdGhpcyBzY29wZSxcblx0ICogY3JlYXRlIHRoZSBjYW52YXMgZWxlbWVudCwgZ3JhYiB0aGUgMkQgY29udGV4dCBmb3IgdGhhdCBjYW52YXNcblx0ICogc2V0IHRoZSBjYW52YXMgZWxlbWVudHMgaGVpZ2h0L3dpZHRoIGFuZCBhZGQgaXQgdG8gdGhlIERPTS5cblx0ICovXG5cdHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQsXG5cdFx0d2luID0gZ2xvYmFsLndpbmRvdyxcblx0XHRjYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXG5cdFx0Y3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG5cdFx0bGFzdFRpbWUsXG5cdFx0cnVubmluZyA9IGZhbHNlLFxuXHRcdGluc3RhbmNlID0gZnVuY3Rpb24gaW5zdGFuY2UoKSB7fTtcblxuXHRpbnN0YW5jZS5lbnRpdGllcyA9IFtdO1xuXHRpbnN0YW5jZS53aWR0aCA9IGNhbnZhcy53aWR0aCA9IDUwNTtcblx0aW5zdGFuY2UuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IDYwNjtcblx0Y2FudmFzLmNsYXNzTmFtZSArPSAnIGNhbnZhcy1nYW1lJztcblx0ZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xldmVsJylbMF0uYXBwZW5kQ2hpbGQoY2FudmFzKTtcblxuXHQvKiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgdXBkYXRlIGZ1bmN0aW9uICBhbmQgbG9vcHMgdGhyb3VnaCBhbGwgb2YgdGhlXG5cdCAqIG9iamVjdHMgd2l0aGluIHlvdXIgaW5zdGFuY2UuZW50aXRpZXMgYXJyYXkgYXMgZGVmaW5lZCBpbiBhcHAuanMgYW5kIGNhbGxzXG5cdCAqIHRoZWlyIHVwZGF0ZSgpIG1ldGhvZHMuIEl0IHdpbGwgdGhlbiBjYWxsIHRoZSB1cGRhdGUgZnVuY3Rpb24gZm9yIHlvdXJcblx0ICogcGxheWVyIG9iamVjdC4gVGhlc2UgdXBkYXRlIG1ldGhvZHMgc2hvdWxkIGZvY3VzIHB1cmVseSBvbiB1cGRhdGluZ1xuXHQgKiB0aGUgZGF0YS9wcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gIHRoZSBvYmplY3QuIERvIHlvdXIgZHJhd2luZyBpbiB5b3VyXG5cdCAqIHJlbmRlciBtZXRob2RzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlRW50aXRpZXMoZHQpIHtcblx0XHRpbnN0YW5jZS5lbnRpdGllcy5mb3JFYWNoKGZ1bmN0aW9uIEVhY2hFbmVteShlbmVteSkge1xuXHRcdFx0ZW5lbXkudXBkYXRlKGR0KTtcblx0XHR9KTtcblx0XHRwbGF5ZXIudXBkYXRlKGR0KTtcblx0fVxuXG5cdC8qIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IG1haW4gKG91ciBnYW1lIGxvb3ApIGFuZCBpdHNlbGYgY2FsbHMgYWxsXG5cdCAqIG9mIHRoZSBmdW5jdGlvbnMgd2hpY2ggbWF5IG5lZWQgdG8gdXBkYXRlIGVudGl0eSdzIGRhdGEuIEJhc2VkIG9uIGhvd1xuXHQgKiB5b3UgaW1wbGVtZW50IHlvdXIgY29sbGlzaW9uIGRldGVjdGlvbiAod2hlbiB0d28gZW50aXRpZXMgb2NjdXB5IHRoZVxuXHQgKiBzYW1lIHNwYWNlLCBmb3IgaW5zdGFuY2Ugd2hlbiB5b3VyIGNoYXJhY3RlciBzaG91bGQgZGllKSwgeW91IG1heSBmaW5kXG5cdCAqIHRoZSBuZWVkIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGZ1bmN0aW9uIGNhbGwgaGVyZS4gRm9yIG5vdywgd2UndmUgbGVmdFxuXHQgKiBpdCBjb21tZW50ZWQgb3V0IC0geW91IG1heSBvciBtYXkgbm90IHdhbnQgdG8gaW1wbGVtZW50IHRoaXNcblx0ICogZnVuY3Rpb25hbGl0eSB0aGlzIHdheSAoeW91IGNvdWxkIGp1c3QgaW1wbGVtZW50IGNvbGxpc2lvbiBkZXRlY3Rpb25cblx0ICogb24gdGhlIGVudGl0aWVzIHRoZW1zZWx2ZXMgd2l0aGluIHlvdXIgYXBwLmpzIGZpbGUpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlKGR0KSB7XG5cdFx0dXBkYXRlRW50aXRpZXMoZHQpO1xuXHRcdC8vIGNoZWNrQ29sbGlzaW9ucygpO1xuXHR9XG5cblx0LyogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIHJlbmRlciBmdW5jdGlvbiBhbmQgaXMgY2FsbGVkIG9uIGVhY2ggZ2FtZVxuXHQgKiB0aWNrLiBJdCdzIHB1cnBvc2UgaXMgdG8gdGhlbiBjYWxsIHRoZSByZW5kZXIgZnVuY3Rpb25zIHlvdSBoYXZlIGRlZmluZWRcblx0ICogb24geW91ciBlbmVteSBhbmQgcGxheWVyIGVudGl0aWVzIHdpdGhpbiBhcHAuanNcblx0ICovXG5cdGZ1bmN0aW9uIHJlbmRlckVudGl0aWVzKCkge1xuXHRcdC8qIExvb3AgdGhyb3VnaCBhbGwgb2YgdGhlIG9iamVjdHMgd2l0aGluIHRoZSBpbnN0YW5jZS5lbnRpdGllcyBhcnJheSBhbmQgY2FsbFxuXHRcdCAqIHRoZSByZW5kZXIgZnVuY3Rpb24geW91IGhhdmUgZGVmaW5lZC5cblx0XHQgKi9cblx0XHR2YXIgaTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgaW5zdGFuY2UuZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGluc3RhbmNlLmVudGl0aWVzW2ldLnJlbmRlcihjdHgpO1xuXHRcdH1cblxuXHRcdHBsYXllci5yZW5kZXIoY3R4KTtcblx0fVxuXG5cdC8qIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGx5IGRyYXdzIHRoZSBcImdhbWUgbGV2ZWxcIiwgaXQgd2lsbCB0aGVuIGNhbGxcblx0ICogdGhlIHJlbmRlckVudGl0aWVzIGZ1bmN0aW9uLiBSZW1lbWJlciwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnlcblx0ICogZ2FtZSB0aWNrIChvciBsb29wIG9mIHRoZSBnYW1lIGVuZ2luZSkgYmVjYXVzZSB0aGF0J3MgaG93IGdhbWVzIHdvcmsgLVxuXHQgKiB0aGV5IGFyZSBmbGlwYm9va3MgY3JlYXRpbmcgdGhlIGlsbHVzaW9uIG9mIGFuaW1hdGlvbiBidXQgaW4gcmVhbGl0eVxuXHQgKiB0aGV5IGFyZSBqdXN0IGRyYXdpbmcgdGhlIGVudGlyZSBzY3JlZW4gb3ZlciBhbmQgb3Zlci5cblx0ICovXG5cdGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHQvKiBUaGlzIGFycmF5IGhvbGRzIHRoZSByZWxhdGl2ZSBVUkwgdG8gdGhlIGltYWdlIHVzZWRcblx0XHQgKiBmb3IgdGhhdCBwYXJ0aWN1bGFyIHJvdyBvZiB0aGUgZ2FtZSBsZXZlbC5cblx0XHQgKi9cblx0XHR2YXIgcm93SW1hZ2VzID0gW1xuXHRcdFx0XHQnaW1hZ2VzL3dhdGVyLWJsb2NrLnBuZycsIC8vIFRvcCByb3cgaXMgd2F0ZXJcblx0XHRcdFx0J2ltYWdlcy9zdG9uZS1ibG9jay5wbmcnLCAvLyBSb3cgMSBvZiAzIG9mIHN0b25lXG5cdFx0XHRcdCdpbWFnZXMvc3RvbmUtYmxvY2sucG5nJywgLy8gUm93IDIgb2YgMyBvZiBzdG9uZVxuXHRcdFx0XHQnaW1hZ2VzL3N0b25lLWJsb2NrLnBuZycsIC8vIFJvdyAzIG9mIDMgb2Ygc3RvbmVcblx0XHRcdFx0J2ltYWdlcy9ncmFzcy1ibG9jay5wbmcnLCAvLyBSb3cgMSBvZiAyIG9mIGdyYXNzXG5cdFx0XHRcdCdpbWFnZXMvZ3Jhc3MtYmxvY2sucG5nJyAvLyBSb3cgMiBvZiAyIG9mIGdyYXNzXG5cdFx0XHRdLFxuXHRcdFx0bnVtUm93cyA9IDYsXG5cdFx0XHRudW1Db2xzID0gNSxcblx0XHRcdHJvdywgY29sO1xuXG5cdFx0Ly8gIENsZWFyIHRoZSBlbnRpcmUgY2FudmFzXG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0LyogTG9vcCB0aHJvdWdoIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyB3ZSd2ZSBkZWZpbmVkIGFib3ZlXG5cdFx0ICogYW5kLCB1c2luZyB0aGUgcm93SW1hZ2VzIGFycmF5LCBkcmF3IHRoZSBjb3JyZWN0IGltYWdlIGZvciB0aGF0XG5cdFx0ICogcG9ydGlvbiBvZiB0aGUgXCJncmlkXCJcblx0XHQgKi9cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IG51bVJvd3M7IHJvdysrKSB7XG5cdFx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IG51bUNvbHM7IGNvbCsrKSB7XG5cdFx0XHRcdC8qIFRoZSBkcmF3SW1hZ2UgZnVuY3Rpb24gb2YgdGhlIGNhbnZhcycgY29udGV4dCBlbGVtZW50XG5cdFx0XHRcdCAqIHJlcXVpcmVzIDMgcGFyYW1ldGVyczogdGhlIGltYWdlIHRvIGRyYXcsIHRoZSB4IGNvb3JkaW5hdGVcblx0XHRcdFx0ICogdG8gc3RhcnQgZHJhd2luZyBhbmQgdGhlIHkgY29vcmRpbmF0ZSB0byBzdGFydCBkcmF3aW5nLlxuXHRcdFx0XHQgKiBXZSdyZSB1c2luZyBvdXIgUmVzb3VyY2VzIGhlbHBlcnMgdG8gcmVmZXIgdG8gb3VyIGltYWdlc1xuXHRcdFx0XHQgKiBzbyB0aGF0IHdlIGdldCB0aGUgYmVuZWZpdHMgb2YgY2FjaGluZyB0aGVzZSBpbWFnZXMsIHNpbmNlXG5cdFx0XHRcdCAqIHdlJ3JlIHVzaW5nIHRoZW0gb3ZlciBhbmQgb3Zlci5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoUmVzb3VyY2VzLmdldChyb3dJbWFnZXNbcm93XSksIGNvbCAqIDEwMSwgcm93ICogODMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJlbmRlckVudGl0aWVzKCk7XG5cdH1cblxuXHQvKiBUaGlzIGZ1bmN0aW9uIHNlcnZlcyBhcyB0aGUga2lja29mZiBwb2ludCBmb3IgdGhlIGdhbWUgbG9vcCBpdHNlbGZcblx0ICogYW5kIGhhbmRsZXMgcHJvcGVybHkgY2FsbGluZyB0aGUgdXBkYXRlIGFuZCByZW5kZXIgbWV0aG9kcy5cblx0ICovXG5cdGZ1bmN0aW9uIG1haW4oKSB7XG5cdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdC8qIEdldCBvdXIgdGltZSBkZWx0YSBpbmZvcm1hdGlvbiB3aGljaCBpcyByZXF1aXJlZCBpZiB5b3VyIGdhbWVcblx0XHRcdCAqIHJlcXVpcmVzIHNtb290aCBhbmltYXRpb24uIEJlY2F1c2UgZXZlcnlvbmUncyBjb21wdXRlciBwcm9jZXNzZXNcblx0XHRcdCAqIGluc3RydWN0aW9ucyBhdCBkaWZmZXJlbnQgc3BlZWRzIHdlIG5lZWQgYSBjb25zdGFudCB2YWx1ZSB0aGF0XG5cdFx0XHQgKiB3b3VsZCBiZSB0aGUgc2FtZSBmb3IgZXZlcnlvbmUgKHJlZ2FyZGxlc3Mgb2YgaG93IGZhc3QgdGhlaXJcblx0XHRcdCAqIGNvbXB1dGVyIGlzKSAtIGh1cnJheSB0aW1lIVxuXHRcdFx0ICovXG5cdFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcblx0XHRcdFx0ZHQgPSAobm93IC0gbGFzdFRpbWUpIC8gMTAwMC4wO1xuXG5cdFx0XHQvKiBDYWxsIG91ciB1cGRhdGUvcmVuZGVyIGZ1bmN0aW9ucywgcGFzcyBhbG9uZyB0aGUgdGltZSBkZWx0YSB0b1xuXHRcdFx0ICogb3VyIHVwZGF0ZSBmdW5jdGlvbiBzaW5jZSBpdCBtYXkgYmUgdXNlZCBmb3Igc21vb3RoIGFuaW1hdGlvbi5cblx0XHRcdCAqL1xuXHRcdFx0dXBkYXRlKGR0KTtcblx0XHRcdHJlbmRlcigpO1xuXG5cdFx0XHQvKiBTZXQgb3VyIGxhc3RUaW1lIHZhcmlhYmxlIHdoaWNoIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB0aW1lIGRlbHRhXG5cdFx0XHQgKiBmb3IgdGhlIG5leHQgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cblx0XHRcdCAqL1xuXHRcdFx0bGFzdFRpbWUgPSBub3c7XG5cblx0XHRcdC8qIFVzZSB0aGUgYnJvd3NlcidzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmdW5jdGlvbiB0byBjYWxsIHRoaXNcblx0XHRcdCAqIGZ1bmN0aW9uIGFnYWluIGFzIHNvb24gYXMgdGhlIGJyb3dzZXIgaXMgYWJsZSB0byBkcmF3IGFub3RoZXIgZnJhbWUuXG5cdFx0XHQgKi9cblx0XHRcdHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobWFpbik7XG5cdFx0fVxuXHR9XG5cblx0LyogVGhpcyBmdW5jdGlvbiBkb2VzIHNvbWUgaW5pdGlhbCBzZXR1cCB0aGF0IHNob3VsZCBvbmx5IG9jY3VyIG9uY2UsXG5cdCAqIHBhcnRpY3VsYXJseSBzZXR0aW5nIHRoZSBsYXN0VGltZSB2YXJpYWJsZSB0aGF0IGlzIHJlcXVpcmVkIGZvciB0aGVcblx0ICogZ2FtZSBsb29wLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRpbnN0YW5jZS5yZXNldCgpO1xuXHRcdHJ1bm5pbmcgPSB0cnVlO1xuXHRcdGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRtYWluKCk7XG5cdH1cblxuXHQvKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90aGluZyBidXQgaXQgY291bGQgaGF2ZSBiZWVuIGEgZ29vZCBwbGFjZSB0b1xuXHQgKiBoYW5kbGUgZ2FtZSByZXNldCBzdGF0ZXMgLSBtYXliZSBhIG5ldyBnYW1lIG1lbnUgb3IgYSBnYW1lIG92ZXIgc2NyZWVuXG5cdCAqIHRob3NlIHNvcnRzIG9mIHRoaW5ncy4gSXQncyBvbmx5IGNhbGxlZCBvbmNlIGJ5IHRoZSBpbml0KCkgbWV0aG9kLlxuXHQgKi9cblx0aW5zdGFuY2UucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcblx0XHRydW5uaW5nID0gZmFsc2U7XG5cdH07XG5cblx0aW5zdGFuY2UucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcblx0XHRydW5uaW5nID0gZmFsc2U7XG5cdH07XG5cblx0aW5zdGFuY2UucHJlbG9hZCA9IGZ1bmN0aW9uIHByZWxvYWQoKSB7XG5cdFx0LyogR28gYWhlYWQgYW5kIGxvYWQgYWxsIG9mIHRoZSBpbWFnZXMgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBuZWVkIHRvXG5cdFx0ICogZHJhdyBvdXIgZ2FtZSBsZXZlbC4gVGhlbiBzZXQgaW5pdCBhcyB0aGUgY2FsbGJhY2sgbWV0aG9kLCBzbyB0aGF0IHdoZW5cblx0XHQgKiBhbGwgb2YgdGhlc2UgaW1hZ2VzIGFyZSBwcm9wZXJseSBsb2FkZWQgb3VyIGdhbWUgd2lsbCBzdGFydC5cblx0XHQgKi9cblxuXHRcdGZ1bmN0aW9uIGxvY2F0aW9ucyhmb2xkZXIsIGZvcm1hdCkge1xuXHRcdFx0dmFyIHJlc291cmNlcyA9IFtcblx0XHRcdFx0J2NoYXItYm95Jyxcblx0XHRcdFx0J2NoYXItY2F0LWdpcmwnLFxuXHRcdFx0XHQnY2hhci1ob3JuLWdpcmwnLFxuXHRcdFx0XHQnY2hhci1waW5rLWdpcmwnLFxuXHRcdFx0XHQnY2hhci1wcmluY2Vzcy1naXJsJyxcblx0XHRcdFx0J2VuZW15LWJ1ZycsXG5cdFx0XHRcdCdHZW0gQmx1ZScsXG5cdFx0XHRcdCdHZW0gR3JlZW4nLFxuXHRcdFx0XHQnR2VtIE9yYW5nZScsXG5cdFx0XHRcdCdncmFzcy1ibG9jaycsXG5cdFx0XHRcdCdIZWFydCcsXG5cdFx0XHRcdCdLZXknLFxuXHRcdFx0XHQnUm9jaycsXG5cdFx0XHRcdCdTZWxlY3RvcicsXG5cdFx0XHRcdCdTdGFyJyxcblx0XHRcdFx0J3N0b25lLWJsb2NrJyxcblx0XHRcdFx0J3dhdGVyLWJsb2NrJ1xuXHRcdFx0XTtcblx0XHRcdHJldHVybiByZXNvdXJjZXMubWFwKGZ1bmN0aW9uIHJlc291cmNlTWFwKGVsKSB7XG5cdFx0XHRcdHJldHVybiBmb2xkZXIgKyBlbCArICcuJyArIGZvcm1hdDtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRSZXNvdXJjZXMubG9hZChsb2NhdGlvbnMoJ2ltYWdlcy8nLCAncG5nJykpO1xuXG5cdFx0aWYgKFJlc291cmNlcy5pc1JlYWR5KCkpIHtcblx0XHRcdGluaXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0UmVzb3VyY2VzLm9uUmVhZHkoaW5pdCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIEFzc2lnbiB0aGUgY2FudmFzJyBjb250ZXh0IG9iamVjdCB0byB0aGUgZ2xvYmFsIHZhcmlhYmxlICh0aGUgd2luZG93XG5cdCAqIG9iamVjdCB3aGVuIHJ1biBpbiBhIGJyb3dzZXIpIHNvIHRoYXQgZGV2ZWxvcGVyJ3MgY2FuIHVzZSBpdCBtb3JlIGVhc2lseVxuXHQgKiBmcm9tIHdpdGhpbiB0aGVpciBhcHAuanMgZmlsZXMuXG5cdCAqL1xuXHRnbG9iYWwuY3R4ID0gY3R4O1xuXG5cdHJldHVybiBpbnN0YW5jZTtcbn0pKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4qIEBkZXNjcmlwdGlvbiBNb2RlbCBTaW5nbGV0b24gdXNlZCBmb3Igc3RvcmluZyBzdGF0ZSBkYXRhXG4qIEBjb25zdHJ1Y3RvclxuKi9cbnZhciBNb2RlbCA9IChmdW5jdGlvbiBNb2RlbCgpIHtcblx0dmFyIGRhdGEgPSB7fTtcblx0dmFyIGluc3RhbmNlID0gZnVuY3Rpb24gaW5zdGFuY2UoKSB7fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFNldHMgYSB2YWx1ZSB0byBhIGtleVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIHByb3BlcnR5IHRvIHN0b3JlIHRoZSB2YWx1ZSB1bmRlclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGtleVxuXHQgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBrZXlcblx0ICovXG5cdGluc3RhbmNlLnNldCA9IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG5cdFx0ZGF0YVtrZXldID0gdmFsdWU7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgdmFsdWUgc2V0IHRvIHRoZSBrZXlcblx0ICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBvZiB0aGUga2V5XG5cdCAqL1xuXHRpbnN0YW5jZS5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5KSB7XG5cdFx0cmV0dXJuIGRhdGFba2V5XTtcblx0fTtcblxuXHRyZXR1cm4gaW5zdGFuY2U7XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4qIEBkZXNjcmlwdGlvbiBBIFRpbWVyIGNsYXNzIHRoYXQgdXBkYXRlcyBtYW51YWxseSB1c2luZyB3aXRoIGRlbHRhIHRpbWVcbiogQGNvbnN0cnVjdG9yXG4qL1xudmFyIFRpbWVyID0gZnVuY3Rpb24gVGltZXIoaW50ZXJ2YWxzLCBkZWxheSkge1xuXHR0aGlzLmludGVydmFscyA9IGludGVydmFscztcblx0dGhpcy5kZWxheSA9IGRlbGF5O1xuXHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0dGhpcy5saXN0ZW5lcnMgPSB7fTtcblx0dGhpcy50aW1lID0gMDtcblx0dGhpcy5sYXBzID0gMDtcbn07XG5cbihmdW5jdGlvbiBQcm90b3R5cGUoKSB7XG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmVzZXRzIHRoZSB0aW1lciBhbmQgZmxhZ3MgaXQgYXMgcnVubmluZ1xuXHQgKi9cblx0dGhpcy5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0dGhpcy50aW1lID0gdGhpcy5kZWxheTtcblx0XHR0aGlzLmxhcHMgPSB0aGlzLmludGVydmFscztcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFVzZXMgdGhlIGRlbHRhIHRpbWUgdG8gbWFudWFsbHkgdXBkYXRlIHRoZSB0aW1lclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgLSBUaW1lIHNpbmNlIGxhc3QgdXBkYXRlXG5cdCAqL1xuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkZWx0YSkge1xuXHRcdGlmICh0aGlzLnJ1bm5pbmcpIHtcblx0XHRcdHRoaXMudGltZSA9IE1hdGgubWF4KDAsIHRoaXMudGltZSAtIGRlbHRhKTtcblx0XHRcdGlmICh0aGlzLnRpbWUgPT09IDApIHtcblx0XHRcdFx0dGhpcy5sYXBzIC09IDE7XG5cdFx0XHRcdGlmICh0aGlzLmxhcHMgPD0gMCkge1xuXHRcdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2goJ0NPTVBMRVRFJyk7XG5cdFx0XHRcdH1lbHNlIHtcblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aGlzLmRlbGF5O1xuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2goJ1VQREFURScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gQWRkcyBhIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG5cdCAqL1xuXHR0aGlzLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYgKCF0aGlzLmxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcblx0XHRcdHRoaXMubGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLmxpc3RlbmVyc1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBBdHRlbXB0cyB0byBpbnZva2UgYSBjYWxsYmFjayBtZXRob2QgZm9yIHRoZSBnaXZlbiBldmVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgdG8gZGlzcGF0Y2hcblx0ICovXG5cdHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaChldmVudCkge1xuXHRcdHZhciBpO1xuXHRcdHZhciBsaXN0O1xuXHRcdGlmICh0aGlzLmxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcblx0XHRcdGxpc3QgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsaXN0W2ldKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0pLmNhbGwoVGltZXIucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gR3JpZCBTaW5nbGV0b24gdXNlZCBmb3IgcG9zaXRpb25pbmcgdGhpbmdzIG9uIGEgR3JpZFxuKiBAY29uc3RydWN0b3JcbiovXG52YXIgR3JpZCA9IChmdW5jdGlvbiBHcmlkKCkge1xuXHR2YXIgaW5zdGFuY2UgPSBmdW5jdGlvbiBpbnN0YW5jZSgpIHt9O1xuXG5cdGluc3RhbmNlLmNlbGxXaWR0aCA9IDEwMTtcblx0aW5zdGFuY2UuY2VsbEhlaWdodCA9IDgzO1xuXHRpbnN0YW5jZS5jb2x1bW5zID0gNTtcblx0aW5zdGFuY2Uucm93cyA9IDY7XG5cdGluc3RhbmNlLm9mZnNldFkgPSA1MDtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIERldGVybWluZXMgdGhlIHggbG9jYXRpb24gYmFzZWQgb24gdGhlIGNvbHVtblxuXHQgKiBAcGFyYW0ge2ludH0gY29sdW1uIC0gVGhlIGNvbHVtblxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc2NyZWVuIHggcG9zaXRpb25cblx0ICovXG5cdGluc3RhbmNlLmdldFhGcm9tQ29sdW1uID0gZnVuY3Rpb24gZ2V0WEZyb21Db2x1bW4oY29sdW1uKSB7XG5cdFx0dmFyIGNvbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNvbHVtbiwgaW5zdGFuY2UuY29sdW1ucyAtIDEpKTtcblx0XHRyZXR1cm4gY29sICogaW5zdGFuY2UuY2VsbFdpZHRoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gRGV0ZXJtaW5lcyB0aGUgeSBsb2NhdGlvbiBiYXNlZCBvbiB0aGUgcm93XG5cdCAqIEBwYXJhbSB7aW50fSByb3cgLSBUaGUgcm93XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzY3JlZW4geSBwb3NpdGlvblxuXHQgKi9cblx0aW5zdGFuY2UuZ2V0WUZyb21Sb3cgPSBmdW5jdGlvbiBnZXRZRnJvbVJvdyhyb3cpIHtcblx0XHRyb3cgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyb3csIGluc3RhbmNlLnJvd3MgLSAxKSk7XG5cdFx0cmV0dXJuIGluc3RhbmNlLm9mZnNldFkgKyByb3cgKiBpbnN0YW5jZS5jZWxsSGVpZ2h0O1xuXHR9O1xuXG5cdHJldHVybiBpbnN0YW5jZTtcbn0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiogQGRlc2NyaXB0aW9uIEhhbmRsZXMgbGV2ZWwgY3JlYXRpb25cbiogQGNvbnN0cnVjdG9yXG4qL1xudmFyIExldmVsID0gZnVuY3Rpb24gTGV2ZWwoKSB7XG5cdHRoaXMucmVzZXQoKTtcbn07XG5cbihmdW5jdGlvbiBQcm90b3R5cGUoKSB7XG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmVzZXQncyBsZXZlbCB2YXJpYWJsZXMgdG8gb3JpZ2luYWwgdmFsdWVzXG5cdCAqL1xuXHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG5cdFx0dGhpcy5sZXZlbCA9IE1vZGVsLnNldCgnbGV2ZWwnLCAwKTtcblx0XHR0aGlzLmxhc3RMZXZlbCA9IDc7XG5cdFx0TW9kZWwuc2V0KCdsZXZlbF90b3RhbF90aW1lJywgMTUpO1xuXHRcdE1vZGVsLnNldCgnbGV2ZWxfY29tcGxldGUnLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBBZHZhbmNlcyB0aGUgY3VycmVudCBsZXZlbCBieSBvbmVcblx0ICovXG5cdHRoaXMubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0dGhpcy5sZXZlbCA9IE1vZGVsLnNldCgnbGV2ZWwnLCB0aGlzLmxldmVsICsgMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGFsbCB0aGUgZW50aXRpZXMgZm9yIHRoZSBjdXJyZW50IGxldmVsXG5cdCAqL1xuXHR0aGlzLmFkZEVudGl0aWVzID0gZnVuY3Rpb24gYWRkRW50aXRpZXMoKSB7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLmxldmVsRGF0YSgpO1xuXHRcdHZhciBpO1xuXHRcdEVuZ2luZS5lbnRpdGllcyA9IFtdO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChkYXRhW2ldLmhhc093blByb3BlcnR5KCd0JykpIHtcblx0XHRcdFx0aWYgKGRhdGFbaV0udCA9PT0gJ2tleScpIHtcblx0XHRcdFx0XHRFbmdpbmUuZW50aXRpZXMucHVzaChuZXcgS2V5KGRhdGFbaV0uciwgZGF0YVtpXS5jKSk7XG5cdFx0XHRcdH1lbHNlIGlmIChkYXRhW2ldLnQgPT09ICd3YXRlcicpIHtcblx0XHRcdFx0XHRFbmdpbmUuZW50aXRpZXMucHVzaChuZXcgV2F0ZXIoZGF0YVtpXS5yLCBkYXRhW2ldLmMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2Uge1xuXHRcdFx0XHRFbmdpbmUuZW50aXRpZXMucHVzaChuZXcgRW5lbXkoZGF0YVtpXS5yLCBkYXRhW2ldLmMsIGRhdGFbaV0ucykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIEpTT04gZW50aXRpZXMgZm9yIHRoZSBnaXZlbiBsZXZlbFxuXHQgKiBAcmV0dXJucyB7YXJyYXl9XG5cdCAqL1xuXHR0aGlzLmxldmVsRGF0YSA9IGZ1bmN0aW9uIGxldmVsRGF0YSgpIHtcblx0XHQvLyAgRm9ybWF0dGVkIHNvIGl0J3MgZWFzaWVyIHRvIHNlZSB0aGUgbGV2ZWxzIChub3QgZm9sbG93aW5nIFVkYWNpdHkgSlMgc3RhbmRhcmRzKVxuXHRcdC8vICBqc2NzOmRpc2FibGVcblx0XHRpZiAodGhpcy5sZXZlbCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdHtyOiAwLCBjOiAwLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDEsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMiwgdDogJ2tleSd9LCB7cjogMCwgYzogMywgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiA0LCB0OiAnd2F0ZXInfVxuXHRcdFx0XTtcblx0XHR9ZWxzZSBpZiAodGhpcy5sZXZlbCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdHtyOiAzLCBjOiAwLCBzOiAyMDB9LCB7cjogMywgYzogMiwgczogMjAwfSwge3I6IDMsIGM6IDQsIHM6IDIwMH0sXG5cdFx0XHR7cjogMCwgYzogMCwgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiAxLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDIsIHQ6ICdrZXknfSwge3I6IDAsIGM6IDMsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogNCwgdDogJ3dhdGVyJ31cblx0XHRcdF07XG5cdFx0fWVsc2UgaWYgKHRoaXMubGV2ZWwgPT09IDIpIHtcblx0XHRcdHJldHVybiBbXG5cdFx0XHR7cjogMSwgYzogMCwgczogLTEwMH0sIHtyOiAxLCBjOiAxLCBzOiAtMTAwfSwge3I6IDEsIGM6IDMsIHM6IC0xMDB9LCB7cjogMSwgYzogNCwgczogLTEwMH0sXG5cdFx0XHR7cjogMCwgYzogMCwgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiAxLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDIsIHQ6ICdrZXknfSwge3I6IDAsIGM6IDMsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogNCwgdDogJ3dhdGVyJ31cblx0XHRcdF07XG5cdFx0fWVsc2UgaWYgKHRoaXMubGV2ZWwgPT09IDMpIHtcblx0XHRcdHJldHVybiBbXG5cdFx0XHR7cjogMiwgYzogMCwgczogNTAwfSwge3I6IDIsIGM6IDQsIHM6IDYwMH0sXG5cdFx0XHR7cjogMCwgYzogMCwgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiAxLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDIsIHQ6ICdrZXknfSwge3I6IDAsIGM6IDMsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogNCwgdDogJ3dhdGVyJ31cblx0XHRcdF07XG5cdFx0fWVsc2UgaWYgKHRoaXMubGV2ZWwgPT09IDQpIHtcblx0XHRcdHJldHVybiBbXG5cdFx0XHR7cjogMSwgYzogMCwgczogLTEwMH0sIHtyOiAxLCBjOiAxLCBzOiAtMTAwfSwge3I6IDEsIGM6IDMsIHM6IC0xMDB9LCB7cjogMSwgYzogNCwgczogLTEwMH0sXG5cdFx0XHR7cjogMywgYzogMCwgczogMjAwfSwge3I6IDMsIGM6IDIsIHM6IDIwMH0sIHtyOiAzLCBjOiA0LCBzOiAyMDB9LFxuXHRcdFx0e3I6IDAsIGM6IDAsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMSwgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiAyLCB0OiAna2V5J30sIHtyOiAwLCBjOiAzLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDQsIHQ6ICd3YXRlcid9XG5cdFx0XHRdO1xuXHRcdH1lbHNlIGlmICh0aGlzLmxldmVsID09PSA1KSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0e3I6IDIsIGM6IDAsIHM6IDUwMH0sIHtyOiAyLCBjOiA0LCBzOiA2MDB9LFxuXHRcdFx0e3I6IDMsIGM6IDAsIHM6IDIwMH0sIHtyOiAzLCBjOiAyLCBzOiAyMDB9LCB7cjogMywgYzogNCwgczogMjAwfSxcblx0XHRcdHtyOiAwLCBjOiAwLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDEsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMiwgdDogJ2tleSd9LCB7cjogMCwgYzogMywgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiA0LCB0OiAnd2F0ZXInfVxuXHRcdFx0XTtcblx0XHR9ZWxzZSBpZiAodGhpcy5sZXZlbCA9PT0gNikge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdHtyOiAxLCBjOiAwLCBzOiAtMTAwfSwge3I6IDEsIGM6IDEsIHM6IC0xMDB9LCB7cjogMSwgYzogMywgczogLTEwMH0sIHtyOiAxLCBjOiA0LCBzOiAtMTAwfSxcblx0XHRcdHtyOiAyLCBjOiAwLCBzOiA1MDB9LCB7cjogMiwgYzogNCwgczogNjAwfSxcblx0XHRcdHtyOiAwLCBjOiAwLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDEsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMiwgdDogJ2tleSd9LCB7cjogMCwgYzogMywgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiA0LCB0OiAnd2F0ZXInfVxuXHRcdFx0XTtcblx0XHR9XG5cdFx0Ly8gIGpzY3M6ZGlzYWJsZVxuXHRcdHJldHVybiBbXG5cdFx0e3I6IDEsIGM6IDAsIHM6IC0xMDB9LCB7cjogMSwgYzogMSwgczogLTEwMH0sIHtyOiAxLCBjOiAzLCBzOiAtMTAwfSwge3I6IDEsIGM6IDQsIHM6IC0xMDB9LFxuXHRcdHtyOiAyLCBjOiAwLCBzOiA1MDB9LCB7cjogMiwgYzogNCwgczogNjAwfSxcblx0XHR7cjogMywgYzogMCwgczogMjAwfSwge3I6IDMsIGM6IDIsIHM6IDIwMH0sIHtyOiAzLCBjOiA0LCBzOiAyMDB9LFxuXHRcdHtyOiAwLCBjOiAwLCB0OiAnd2F0ZXInfSwge3I6IDAsIGM6IDEsIHQ6ICd3YXRlcid9LCB7cjogMCwgYzogMiwgdDogJ2tleSd9LCB7cjogMCwgYzogMywgdDogJ3dhdGVyJ30sIHtyOiAwLCBjOiA0LCB0OiAnd2F0ZXInfVxuXHRcdF07XG5cdH07XG59KS5jYWxsKExldmVsLnByb3RvdHlwZSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBTY2VuZSBTaW5nbGV0b24gdXNlZCBmb3IgY2hhbmdpbmcgdGhlIHNjZW5lIHZpZXdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2NlbmUgPSAoZnVuY3Rpb24gU2NlbmUoKSB7XG5cdHZhciBpbnN0YW5jZSA9IGZ1bmN0aW9uIGluc3RhbmNlKCkge307XG5cdHZhciBsZXZlbCA9IG5ldyBMZXZlbCgpO1xuXHR2YXIgb25DaGFyYWN0ZXJDbGlja2VkID0gZnVuY3Rpb24gb25DaGFyYWN0ZXJDbGlja2VkKGVsKSB7XG5cdFx0dmFyIHMgPSBlbC50YXJnZXQuc3JjO1xuXHRcdHBsYXllci5zcHJpdGUgPSBzLnNsaWNlKHMuaW5kZXhPZignL2ltYWdlcy8nKSArIDEsIHMubGVuZ3RoKTtcblxuXHRcdEVsLnJlbW92ZUNsYXNzKEVsLmdldEVsZW1lbnRzKCdzZWxlY3RlZC1jaGFyJyksICdzZWxlY3RlZC1jaGFyJyk7XG5cdFx0RWwuYWRkQ2xhc3MoZWwudGFyZ2V0LCAnc2VsZWN0ZWQtY2hhcicpO1xuXHR9O1xuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFNob3dzIHRoZSBDaGFyYWN0ZXIgc2VsZWN0aW9uIHNjZW5lXG5cdCAqL1xuXHRpbnN0YW5jZS5zdGFydE1lbnUgPSBmdW5jdGlvbiBzdGFydE1lbnUoKSB7XG5cdFx0dmFyIGNoYXJhY3RlcnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjaGFyJyk7XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hhcmFjdGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y2hhcmFjdGVyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2hhcmFjdGVyQ2xpY2tlZCk7XG5cdFx0fVxuXG5cdFx0RW5naW5lLnJlc2V0KCk7XG5cblx0XHRFbC5zaG93KCdjaGFyX3NlbGVjdCcpO1xuXHRcdEVsLmhpZGUoJ2xldmVsJyk7XG5cdFx0RWwuaGlkZSgnZ2FtZW92ZXInKTtcblx0XHRFbC5oaWRlKCdnYW1ld2luJyk7XG5cdFx0c2NlbmUgPSAnY2hhcl9zZWxlY3QnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gU2hvd3MgdGhlIEdhbWUgc2NlbmVcblx0ICovXG5cdGluc3RhbmNlLnN0YXJ0R2FtZSA9IGZ1bmN0aW9uIHN0YXJ0R2FtZShyZXNldCkge1xuXHRcdHJlc2V0ID0gcmVzZXQgfHwgZmFsc2U7XG5cblx0XHRpZiAocmVzZXQpIHtcblx0XHRcdGxldmVsLnJlc2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdE1vZGVsLnNldCgnbGV2ZWxfY29tcGxldGUnLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0RW5naW5lLnByZWxvYWQoKTtcblx0XHRwbGF5ZXIucmVzcGF3bigpO1xuXG5cdFx0bGV2ZWwuYWRkRW50aXRpZXMoKTtcblx0XHRFbmdpbmUuZW50aXRpZXMucHVzaCh1aSk7XG5cdFx0dWkuc3RhcnQoKTtcblxuXHRcdEVsLnNob3coJ2xldmVsJyk7XG5cdFx0RWwuaGlkZSgnY2hhcl9zZWxlY3QnKTtcblx0XHRFbC5oaWRlKCdnYW1lb3ZlcicpO1xuXHRcdEVsLmhpZGUoJ2dhbWV3aW4nKTtcblx0XHRzY2VuZSA9ICdsZXZlbCc7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBTaG93cyB0aGUgR2FtZSBPdmVyIHBvcHVwXG5cdCAqL1xuXHRpbnN0YW5jZS5lbmRHYW1lID0gZnVuY3Rpb24gZW5kR2FtZSgpIHtcblx0XHRFbC5zaG93KCdnYW1lb3ZlcicpO1xuXHRcdEVuZ2luZS5wYXVzZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gU2hvd3MgdGhlIEdhbWUgV2luIHBvcHVwXG5cdCAqL1xuXHRpbnN0YW5jZS53aW5HYW1lID0gZnVuY3Rpb24gd2luR2FtZSgpIHtcblx0XHRFbC5zaG93KCdnYW1ld2luJyk7XG5cdFx0RW5naW5lLnBhdXNlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGUgcGxheWVyIHBpY2tlZCB1cCB0aGUga2V5LiBTaG93IHN0YXIgZXhwbG9zaW9uIGFuZCBhZHZhbmNlIGxldmVsIGFmdGVyIHRpbWVvdXRcblx0ICovXG5cdGluc3RhbmNlLmxldmVsQ29tcGxldGUgPSBmdW5jdGlvbiBsZXZlbENvbXBsZXRlKCkge1xuXHRcdE1vZGVsLnNldCgnbGV2ZWxfY29tcGxldGUnLCB0cnVlKTtcblx0XHRFbmdpbmUuZW50aXRpZXMucHVzaChuZXcgRXhwbG9zaW9uKDAsIDIpKTtcblx0XHRzZXRUaW1lb3V0KGluc3RhbmNlLm5leHRMZXZlbCwgMTUwMCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBBZHZhbmNlIHRvIHRoZSBuZXh0IGxldmVsIG9yIGVuZCB0aGUgZ2FtZSBpZiBubyBtb3JlIGxldmVsc1xuXHQgKi9cblx0aW5zdGFuY2UubmV4dExldmVsID0gZnVuY3Rpb24gbmV4dExldmVsKCkge1xuXHRcdGxldmVsLm5leHQoKTtcblxuXHRcdGlmIChsZXZlbC5sZXZlbCA+IGxldmVsLmxhc3RMZXZlbCkge1xuXHRcdFx0aW5zdGFuY2Uud2luR2FtZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnN0YW5jZS5zdGFydEdhbWUoKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGluc3RhbmNlO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gQSBzZW5zb3IgdXNlZCBhcyBhIGNvbGxpc2lvbiBib3ggdGhhdCBjYW4gYmUgcmVuZGVyZWQgdG8gdGhlIHNjcmVlbiBmb3IgdGVzdGluZ1xuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBsb2NhdGlvblxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGxvY2F0aW9uXG4qIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIEhvdyBsb25nIHRoZSBzZW5zb3IgaXNcbiogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhvdyB0YWxsIHRoZSBzZW5zb3IgaXNcbiogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBUaGUgb2Zmc2V0IGluIHRoZSB4IGRpcmVjdGlvblxuKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFRoZSBvZmZzZXQgaW4gdGhlIHkgZGlyZWN0aW9uXG4qL1xudmFyIFNlbnNvciA9IGZ1bmN0aW9uIFNlbnNvcih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKSB7XG5cdHRoaXMueCA9IHg7XG5cdHRoaXMueSA9IHk7XG5cdHRoaXMud2lkdGggPSB3aWR0aDtcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XG5cdHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG5cdHRoaXMuZGVidWcgPSBmYWxzZTtcbn07XG5cbihmdW5jdGlvbiBQcm90b3R5cGUoKSB7XG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmVuZGVycyB0aGlzIGVudGl0eSB0byB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7Y29udGV4dH0gY3R4IC0gVGhlIGNhbnZhcydzIGNvbnRleHRcblx0ICovXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGN0eCkge1xuXHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcblx0XHRcdGN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gVXBkYXRlcyB0aGUgc2Vuc29yJ3MgcG9zaXRpb25cblx0ICogQHBhcmFtIHtpbnR9IHggLSBUaGUgeCBsb2NhdGlvblxuXHQgKiBAcGFyYW0ge2ludH0geSAtIFRoZSB5IGxvY2F0aW9uXG5cdCAqL1xuXHR0aGlzLnBvc2l0aW9uID0gZnVuY3Rpb24gcG9zaXRpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHggKyB0aGlzLm9mZnNldFg7XG5cdFx0dGhpcy55ID0geSArIHRoaXMub2Zmc2V0WTtcblx0fTtcbn0pLmNhbGwoU2Vuc29yLnByb3RvdHlwZSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiogQGRlc2NyaXB0aW9uIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyB0aGUgb3duZXJzIHNwcml0ZSBhY2NvcmRpbmcgdG8gcG9zaXRpb24sIGFscGhhIGFuZCBkaXJlY3Rpb25cbiogQGNvbnN0cnVjdG9yXG4qL1xudmFyIFJlbmRlciA9IGZ1bmN0aW9uIFJlbmRlcihvd25lcikge1xuXHR0aGlzLm93bmVyID0gb3duZXI7XG59O1xuXG4oZnVuY3Rpb24gUHJvdG90eXBlKCkge1xuXHR2YXIgcCA9IHt4OiAwLCB5OiAwfTtcblx0LyoqXG5cdCAgKiBAZGVzY3JpcHRpb24gUmVuZGVycyB0aGUgb3duZXIncyBzcHJpdGVcblx0ICAqIEBwYXJhbSB7Y29udGV4dH0gY3R4IC0gVGhlIGNhbnZhcydzIGNvbnRleHRcblx0ICAqL1xuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjdHgpIHtcblx0XHR2YXIgZmxpcHBlZCA9IHRoaXMub3duZXIuZmxpcHBlZCA/IC0xIDogMTtcblx0XHR2YXIgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LnNjYWxlKGZsaXBwZWQsIDEpO1xuXHRcdGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3duZXIuYWxwaGEgfHwgMTtcblx0XHRjdHguZHJhd0ltYWdlKFJlc291cmNlcy5nZXQodGhpcy5vd25lci5zcHJpdGUpLCBwb3MueCwgcG9zLnksIDEwMSwgMTcxKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGZvcm1hdHRlZCBwb3NpdGlvblxuXHQgICovXG5cdHRoaXMuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbigpIHtcblx0XHR2YXIgZmxpcHBlZCA9IHRoaXMub3duZXIuZmxpcHBlZCA/IC0xIDogMTtcblx0XHRwLnggPSAodGhpcy5vd25lci54ICsgdGhpcy5vd25lci5vZmZzZXRYKSAqIGZsaXBwZWQ7XG5cdFx0cC54ICs9IChmbGlwcGVkID09PSAxID8gMCA6IC0xMDEpO1xuXHRcdHAueSA9IHRoaXMub3duZXIueSArIHRoaXMub3duZXIub2Zmc2V0WTtcblx0XHRyZXR1cm4gcDtcblx0fTtcbn0pLmNhbGwoUmVuZGVyLnByb3RvdHlwZSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiogQGRlc2NyaXB0aW9uIFRoZSBpbmdhbWUgaW5mb3JtYXRpb24gZGlzcGxheVxuKiBAY29uc3RydWN0b3JcbiovXG52YXIgVUkgPSBmdW5jdGlvbiBVSSgpIHtcblx0dGhpcy5rZXlzID0gMDtcblx0dGhpcy5sZXZlbFRpbWUgPSAwO1xuXHR0aGlzLnRpbWUgPSAwO1xufTtcblxuKGZ1bmN0aW9uIFByb3RvdHlwZSgpIHtcblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXNldHMgdGhlIGxldmVsIGluZm9ybWF0aW9uIGFuZCBzdGFydHMgdGhlIGdhbWUgdGltZXJcblx0ICovXG5cdHRoaXMuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcblx0XHR0aGlzLmtleXMgPSBNb2RlbC5nZXQoJ2xldmVsJyk7XG5cdFx0dGhpcy5sZXZlbFRpbWUgPSBNb2RlbC5nZXQoJ2xldmVsX3RvdGFsX3RpbWUnKTtcblxuXHRcdHRoaXMubGV2ZWxUaW1lciA9IG5ldyBUaW1lcigxLCB0aGlzLmxldmVsVGltZSk7XG5cdFx0dGhpcy5sZXZlbFRpbWVyLm9uKCdDT01QTEVURScsIHRoaXMub25UaW1lckNvbXBsZXRlKTtcblx0XHR0aGlzLmxldmVsVGltZXIuc3RhcnQoKTtcblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFRoZSBsZXZlbCB0aW1lciBoYXMgY29tcGxldGVkXG5cdCAqL1xuXHR0aGlzLm9uVGltZXJDb21wbGV0ZSA9IGZ1bmN0aW9uIG9uVGltZXJDb21wbGV0ZSgpIHtcblx0XHRpZiAoIU1vZGVsLmdldCgnbGV2ZWxfY29tcGxldGUnKSkge1xuXHRcdFx0U2NlbmUuZW5kR2FtZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIEZvcm1hdGVkIHN0cmluZyBvZiB0aW1lIGxlZnQgKGV4cGVjdHMgPjAgJiYgPDYwIHNlY29uZHMpXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFNlY29uZHMgbGVmdCBvbiB0aW1lXG5cdCAqL1xuXHR0aGlzLmZvcm1hdHRlZFRpbWUgPSBmdW5jdGlvbiBmb3JtYXR0ZWRUaW1lKCkge1xuXHRcdHZhciB0aW1lID0gTWF0aC5yb3VuZCh0aGlzLmxldmVsVGltZXIudGltZSk7XG5cdFx0cmV0dXJuICcwMDonICsgKHRpbWUgPiA5ID8gdGltZSA6ICcwJyArIHRpbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmVuZGVycyB0ZXh0IHRvIHRoZSBzY3JlZW5cblx0ICogQHBhcmFtIHtjb250ZXh0fSBjdHggLSBUaGUgY2FudmFzJ3MgY29udGV4dFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIHN0cmluZyB0byBkaXNwbGF5XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggbG9jYXRpb25cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBsb2NhdGlvblxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gLSBUaGUgY2FudmFzJ3MgY29udGV4dFxuXHQgKi9cblx0dGhpcy50ZXh0ID0gZnVuY3Rpb24gdGV4dChjdHgsIHN0cmluZywgeCwgeSwgYWxpZ24pIHtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5mb250ID0gJzMwcHggQ29taWMgU2FucyBNUyc7XG5cdFx0aWYgKGFsaWduID09PSAnbGVmdCcgfHwgYWxpZ24gPT09ICdyaWdodCcgfHwgYWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRjdHgudGV4dEFsaWduID0gYWxpZ247XG5cdFx0fVxuXHRcdGN0eC5maWxsVGV4dChzdHJpbmcsIHgsIHkpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIHRoZSB0aW1lciBhbmQga2V5IGluZm9ybWF0aW9uXG5cdCAqIEBwYXJhbSB7aW50fSBkdCAtIFRpbWUgc2luY2UgbGFzdCB1cGRhdGVcblx0ICovXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGR0KSB7XG5cdFx0aWYgKCFNb2RlbC5nZXQoJ2xldmVsX2NvbXBsZXRlJykpIHtcblx0XHRcdHRoaXMua2V5cyA9IE1vZGVsLmdldCgnbGV2ZWwnKTtcblx0XHRcdHRoaXMubGV2ZWxUaW1lci51cGRhdGUoZHQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlbmRlcnMgdGhpcyBlbnRpdHkgdG8gdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge2NvbnRleHR9IGN0eCAtIFRoZSBjYW52YXMncyBjb250ZXh0XG5cdCAqL1xuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjdHgpIHtcblx0XHR0aGlzLnRleHQoY3R4LCAnS2V5czogeCcgKyB0aGlzLmtleXMsIDAsIDMwKTtcblx0XHR0aGlzLnRleHQoY3R4LCAnVGltZTogJyArIHRoaXMuZm9ybWF0dGVkVGltZSgpLCBFbmdpbmUud2lkdGgsIDMwLCAncmlnaHQnKTtcblx0fTtcbn0pLmNhbGwoVUkucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gS2V5IGVudGl0eVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtpbnR9IHJvdyAtIFRoZSBpbml0aWFsIHJvd1xuKiBAcGFyYW0ge2ludH0gY29sIC0gVGhlIGluaXRpYWwgY29sdW1uXG4qL1xudmFyIEtleSA9IGZ1bmN0aW9uIEtleShyb3csIGNvbCkge1xuXHR0aGlzLmVudGl0eSA9IG5ldyBFbnRpdHkodGhpcyxcblx0XHRHcmlkLmdldFhGcm9tQ29sdW1uKGNvbCksXG5cdFx0R3JpZC5nZXRZRnJvbVJvdyhyb3cpLFxuXHRcdCdpbWFnZXMvS2V5LnBuZycsXG5cdFx0MCxcblx0XHQtKDE3MSAtIDEzOCkgLSBHcmlkLm9mZnNldFkpO1xuXHR0aGlzLnNlbnNvciA9IG5ldyBTZW5zb3IoMCwgMCwgNTAsIDMwLCAyNSwgMjUpO1xuXHR0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcih0aGlzKTtcbn07XG5cbihmdW5jdGlvbiBQcm90b3R5cGUoKSB7XG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGlmIHRoaXMgZW50aXR5IGlzIGNvbGxpZGluZyB3aXRoIHRoZSBwbGF5ZXJcblx0ICogQHBhcmFtIHtpbnR9IGR0IC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZVxuXHQgKi9cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcblx0XHR0aGlzLnNlbnNvci5wb3NpdGlvbih0aGlzLngsIHRoaXMueSk7XG5cdFx0aWYgKHBsYXllciAmJiBwbGF5ZXIuaXNBbGl2ZSAmJiB0aGlzLmlzQWxpdmUpIHtcblx0XHRcdGlmIChDb2xsaXNpb24uaXNDb2xsaWRpbmcodGhpcy5zZW5zb3IsIHBsYXllci5zZW5zb3IpKSB7XG5cdFx0XHRcdHRoaXMuaXNBbGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRwbGF5ZXIuaGl0KCdrZXknKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW5kZXJzIHRoaXMgZW50aXR5IHRvIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtjb250ZXh0fSBjdHggLSBUaGUgY2FudmFzJ3MgY29udGV4dFxuXHQgKi9cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY3R4KSB7XG5cdFx0dGhpcy5yZW5kZXJlci5yZW5kZXIoY3R4KTtcblx0XHR0aGlzLnNlbnNvci5yZW5kZXIoY3R4KTtcblx0fTtcbn0pLmNhbGwoS2V5LnByb3RvdHlwZSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiogQGRlc2NyaXB0aW9uIFdhdGVyIGVudGl0eVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtpbnR9IHJvdyAtIFRoZSBpbml0aWFsIHJvd1xuKiBAcGFyYW0ge2ludH0gY29sIC0gVGhlIGluaXRpYWwgY29sdW1uXG4qL1xudmFyIFdhdGVyID0gZnVuY3Rpb24gV2F0ZXIocm93LCBjb2wpIHtcblx0dGhpcy5lbnRpdHkgPSBuZXcgRW50aXR5KHRoaXMsXG5cdFx0R3JpZC5nZXRYRnJvbUNvbHVtbihjb2wpLFxuXHRcdEdyaWQuZ2V0WUZyb21Sb3cocm93KSxcblx0XHQnaW1hZ2VzL0tleS5wbmcnLFxuXHRcdDAsXG5cdFx0LSgxNzEgLSAxMzgpIC0gR3JpZC5vZmZzZXRZKTtcblx0dGhpcy5zZW5zb3IgPSBuZXcgU2Vuc29yKDAsIDAsIDUwLCAzMCwgMjUsIDI1KTtcbn07XG5cbihmdW5jdGlvbiBQcm90b3R5cGUoKSB7XG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGlmIHRoaXMgZW50aXR5IGlzIGNvbGxpZGluZyB3aXRoIHRoZSBwbGF5ZXJcblx0ICogQHBhcmFtIHtpbnR9IGR0IC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZVxuXHQgKi9cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcblx0XHR0aGlzLnNlbnNvci5wb3NpdGlvbih0aGlzLngsIHRoaXMueSk7XG5cblx0XHRpZiAocGxheWVyICYmIHBsYXllci5pc0FsaXZlKSB7XG5cdFx0XHRpZiAoQ29sbGlzaW9uLmlzQ29sbGlkaW5nKHRoaXMuc2Vuc29yLCBwbGF5ZXIuc2Vuc29yKSkge1xuXHRcdFx0XHRwbGF5ZXIuaGl0KCd3YXRlcicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlbmRlcnMgdGhpcyBlbnRpdHkgdG8gdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge2NvbnRleHR9IGN0eCAtIFRoZSBjYW52YXMncyBjb250ZXh0XG5cdCAqL1xuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjdHgpIHtcblx0XHR0aGlzLnNlbnNvci5yZW5kZXIoY3R4KTtcblx0fTtcbn0pLmNhbGwoV2F0ZXIucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQGRlc2NyaXB0aW9uIEVuZW15IGVudGl0eVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2ludH0gcm93IC0gVGhlIGluaXRpYWwgcm93XG4gKiBAcGFyYW0ge2ludH0gY29sIC0gVGhlIGluaXRpYWwgY29sdW1uXG4gKiBAcGFyYW0ge251bWJlcn0gc3BlZWQgLSBUaGUgaW5pdGlhbCBzcGVlZFxuICovXG52YXIgRW5lbXkgPSBmdW5jdGlvbiBFbmVteShyb3csIGNvbCwgc3BlZWQpIHtcblx0dGhpcy5lbnRpdHkgPSBuZXcgRW50aXR5KHRoaXMsXG5cdFx0R3JpZC5nZXRYRnJvbUNvbHVtbihjb2wpLFxuXHRcdEdyaWQuZ2V0WUZyb21Sb3cocm93KSxcblx0XHQnaW1hZ2VzL2VuZW15LWJ1Zy5wbmcnLFxuXHRcdDAsIC0oMTcxIC0gMTM4KSAtIEdyaWQub2Zmc2V0WSk7XG5cdHRoaXMucm93ID0gcm93O1xuXHR0aGlzLnNwZWVkID0gc3BlZWQ7XG5cdHRoaXMuZmxpcHBlZCA9IHNwZWVkIDwgMDtcblx0dGhpcy5zZW5zb3IgPSBuZXcgU2Vuc29yKDAsIDAsIDUwLCA1MCwgMjUsIDEyKTtcblx0dGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXIodGhpcyk7XG59O1xuXG4oZnVuY3Rpb24gUHJvdG90eXBlKCkge1xuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiB0aGlzIGVudGl0eSBpcyBjb2xsaWRpbmcgd2l0aCB0aGUgcGxheWVyIGFuZCBrZWVwcyB0YXJnZXQgb24gc2NyZWVuIGJ5IHdyYXBwaW5nIHggbG9jYXRpb25cblx0ICogQHBhcmFtIHtpbnR9IGR0IC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZVxuXHQgKi9cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcblx0XHR0aGlzLnggKz0gZHQgKiB0aGlzLnNwZWVkO1xuXG5cdFx0Ly8gIFdyYXBcblx0XHRpZiAodGhpcy54ID4gKEdyaWQuY29sdW1ucyAqIEdyaWQuY2VsbFdpZHRoKSArIEdyaWQuY2VsbFdpZHRoKSB7XG5cdFx0XHR0aGlzLnggPSBHcmlkLmdldFhGcm9tQ29sdW1uKDApIC0gR3JpZC5jZWxsV2lkdGg7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnggPCAtR3JpZC5jZWxsV2lkdGgpIHtcblx0XHRcdHRoaXMueCA9IChHcmlkLmNvbHVtbnMgKiBHcmlkLmNlbGxXaWR0aCkgKyBHcmlkLmNlbGxXaWR0aDtcblx0XHR9XG5cblx0XHR0aGlzLnNlbnNvci5wb3NpdGlvbih0aGlzLngsIHRoaXMueSk7XG5cdFx0aWYgKHBsYXllciAmJiBwbGF5ZXIuaXNBbGl2ZSkge1xuXHRcdFx0aWYgKENvbGxpc2lvbi5pc0NvbGxpZGluZyh0aGlzLnNlbnNvciwgcGxheWVyLnNlbnNvcikpIHtcblx0XHRcdFx0cGxheWVyLmhpdCgnZW5lbXknKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW5kZXJzIHRoaXMgZW50aXR5IHRvIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtjb250ZXh0fSBjdHggLSBUaGUgY2FudmFzJ3MgY29udGV4dFxuXHQgKi9cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY3R4KSB7XG5cdFx0dGhpcy5yZW5kZXJlci5yZW5kZXIoY3R4KTtcblx0XHR0aGlzLnNlbnNvci5yZW5kZXIoY3R4KTtcblx0fTtcbn0pLmNhbGwoRW5lbXkucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gUGxheWVyIGVudGl0eVxuKiBAY29uc3RydWN0b3JcbiovXG52YXIgUGxheWVyID0gZnVuY3Rpb24gUGxheWVyKCkge1xuXHR0aGlzLmVudGl0eSA9IG5ldyBFbnRpdHkodGhpcyxcblx0XHQwLFxuXHRcdDAsXG5cdFx0J2ltYWdlcy9jaGFyLWJveS5wbmcnLFxuXHRcdDAsXG5cdFx0LSgxNzEgLSAxMzgpIC0gR3JpZC5vZmZzZXRZKTtcblx0dGhpcy5pc0FsaXZlID0gZmFsc2U7XG5cdHRoaXMuYWxwaGEgPSAwO1xuXHR0aGlzLnNlbnNvciA9IG5ldyBTZW5zb3IoMCwgMCwgNTAsIDMwLCAyNSwgMjUpO1xuXHR0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcih0aGlzKTtcblx0dGhpcy5ibGlua1RpbWVyID0gbmV3IFRpbWVyKDUsIDAuMik7XG5cblx0dmFyIHJlZiA9IHRoaXM7XG5cblx0dmFyIG9uQmxpbmtUaW1lckNvbXBsZXRlID0gZnVuY3Rpb24gb25CbGlua1RpbWVyQ29tcGxldGUoKSB7XG5cdFx0cmVmLmFscGhhID0gMTtcblx0XHRyZWYuaXNBbGl2ZSA9IHRydWU7XG5cdH07XG5cblx0dmFyIG9uQmxpbmtUaW1lclVwZGF0ZSA9IGZ1bmN0aW9uIG9uQmxpbmtUaW1lclVwZGF0ZSgpIHtcblx0XHRyZWYuYWxwaGEgPSAocmVmLmFscGhhID09PSAwLjQgPyAxIDogMC40KTtcblx0fTtcblxuXHR2YXIgb25LZXlVcCA9IGZ1bmN0aW9uIG9uS2V5VXAoZSkge1xuXHRcdHJlZi5oYW5kbGVJbnB1dChlKTtcblx0fTtcblxuXHR0aGlzLmJsaW5rVGltZXIub24oJ0NPTVBMRVRFJywgb25CbGlua1RpbWVyQ29tcGxldGUpO1xuXHR0aGlzLmJsaW5rVGltZXIub24oJ1VQREFURScsIG9uQmxpbmtUaW1lclVwZGF0ZSk7XG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgb25LZXlVcCk7XG5cblx0dGhpcy5yZXNwYXduKCk7XG59O1xuXG4oZnVuY3Rpb24gUHJvdG90eXBlKCkge1xuXHR2YXIgaW5wdXRNYXAgPSB7XG5cdFx0Mzc6ICdsZWZ0Jyxcblx0XHQzODogJ3VwJyxcblx0XHQzOTogJ3JpZ2h0Jyxcblx0XHQ0MDogJ2Rvd24nXG5cdH07XG5cblx0dmFyIGlucHV0UmVzcG9uc2VNYXAgPSB7XG5cdFx0bGVmdDoge2F4aXM6ICd4JywgZGlyOiAtMX0sXG5cdFx0dXA6IHtheGlzOiAneScsIGRpcjogLTF9LFxuXHRcdHJpZ2h0OiB7YXhpczogJ3gnLCBkaXI6IDF9LFxuXHRcdGRvd246IHtheGlzOiAneScsIGRpcjogMX1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlc2V0cyB0aGUgcGxheWVyIHRvIHRoZSBpbml0aWFsIHBvc2l0aW9uXG5cdCAqL1xuXHR0aGlzLnJlc3Bhd24gPSBmdW5jdGlvbiByZXNwYXduKCkge1xuXHRcdHRoaXMuc2Vuc29yLnggPSB0aGlzLnggPSBHcmlkLmdldFhGcm9tQ29sdW1uKDIpO1xuXHRcdHRoaXMuc2Vuc29yLnkgPSB0aGlzLnkgPSBHcmlkLmdldFlGcm9tUm93KDUpO1xuXHRcdHRoaXMuaXNBbGl2ZSA9IGZhbHNlO1xuXHRcdHRoaXMuYWxwaGEgPSAwLjQ7XG5cdFx0dGhpcy5ibGlua1RpbWVyLnN0YXJ0KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBBIGVudGl0eSBoYXMgaGl0IHRoZSBwbGF5ZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGludm9rZXIgLSBUeXBlIG9mIG9iamVjdCB0aGF0IGhpdCB0aGUgcGxheWVyXG5cdCAqL1xuXHR0aGlzLmhpdCA9IGZ1bmN0aW9uIGhpdChpbnZva2VyKSB7XG5cdFx0aWYgKGludm9rZXIgPT09ICd3YXRlcicgfHwgaW52b2tlciA9PT0gJ2VuZW15Jykge1xuXHRcdFx0dGhpcy5yZXNwYXduKCk7XG5cdFx0fWVsc2UgaWYgKGludm9rZXIgPT09ICdrZXknKSB7XG5cdFx0XHRTY2VuZS5sZXZlbENvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gR2V0cyB0aGUgcG9zaXRpb24gb24gdGhlIGdyaWQgYmFzZWQgb24gcGxheWVyJ3MgaW5wdXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSBUaGUgeCBvciB5IGF4aXNcblx0ICogQHBhcmFtIHtpbnB1dH0gZGlyIC0gVGhlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGRpcmVjdGlvblxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZmluYWwgcG9zaXRpb25cblx0ICovXG5cdHRoaXMuZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiBnZXRNb3ZlbWVudChheGlzLCBkaXIpIHtcblx0XHR2YXIgdjtcblxuXHRcdGlmIChheGlzID09PSAneCcpIHtcblx0XHRcdHYgPSBNYXRoLmZsb29yKHRoaXMueCAvIEdyaWQuY2VsbFdpZHRoKSArIGRpcjtcblx0XHRcdHJldHVybiBHcmlkLmdldFhGcm9tQ29sdW1uKHYpO1xuXHRcdH1cblxuXHRcdHYgPSBNYXRoLmZsb29yKHRoaXMueSAvIEdyaWQuY2VsbEhlaWdodCkgKyBkaXI7XG5cdFx0cmV0dXJuIEdyaWQuZ2V0WUZyb21Sb3codik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBDaGFuZ2VzIHRoZSBwbGF5ZXIgcG9zaXRpb24gYmFzZWQgb24gaW5wdXRcblx0ICogQHBhcmFtIHtldmVudH0gZSAtIFRoZSBldmVudCB0aGF0IG9jY3VyZWRcblx0ICovXG5cdHRoaXMuaGFuZGxlSW5wdXQgPSBmdW5jdGlvbiBoYW5kbGVJbnB1dChlKSB7XG5cdFx0dmFyIGlucHV0ID0gaW5wdXRNYXBbZS5rZXlDb2RlXTtcblx0XHRpZiAoaW5wdXQgJiYgdGhpcy5pc0FsaXZlID09PSB0cnVlICYmICFNb2RlbC5nZXQoJ2xldmVsX2NvbXBsZXRlJykpIHtcblx0XHRcdHZhciBtYXAgPSBpbnB1dFJlc3BvbnNlTWFwW2lucHV0XTtcblxuXHRcdFx0Ly8gIE1vdmVtZW50XG5cdFx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KCdheGlzJykpIHtcblx0XHRcdFx0dGhpc1ttYXAuYXhpc10gPSB0aGlzLmdldE1vdmVtZW50KG1hcC5heGlzLCBtYXAuZGlyKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIHRoZSBwbGF5ZXJzIHRpbWVyIGFuZCBzZW5zb3Jcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR0IC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZVxuXHQgKi9cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcblx0XHR0aGlzLnNlbnNvci5wb3NpdGlvbih0aGlzLngsIHRoaXMueSk7XG5cdFx0aWYgKCF0aGlzLmlzQWxpdmUpIHtcblx0XHRcdHRoaXMuYmxpbmtUaW1lci51cGRhdGUoZHQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlbmRlcnMgdGhpcyBlbnRpdHkgdG8gdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge2NvbnRleHR9IGN0eCAtIFRoZSBjYW52YXMncyBjb250ZXh0XG5cdCAqL1xuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjdHgpIHtcblx0XHR0aGlzLnJlbmRlcmVyLnJlbmRlcihjdHgpO1xuXHRcdHRoaXMuc2Vuc29yLnJlbmRlcihjdHgpO1xuXHR9O1xufSkuY2FsbChQbGF5ZXIucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuKiBAZGVzY3JpcHRpb24gU3RhciBlbnRpdHlcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7aW50fSByb3cgLSBUaGUgaW5pdGlhbCByb3dcbiogQHBhcmFtIHtpbnR9IGNvbCAtIFRoZSBpbml0aWFsIGNvbHVtblxuKi9cbnZhciBTdGFyID0gZnVuY3Rpb24gU3Rhcihyb3csIGNvbCkge1xuXHR0aGlzLmVudGl0eSA9IG5ldyBFbnRpdHkodGhpcyxcblx0XHRHcmlkLmdldFhGcm9tQ29sdW1uKGNvbCksXG5cdFx0R3JpZC5nZXRZRnJvbVJvdyhyb3cpLFxuXHRcdCdpbWFnZXMvU3Rhci5wbmcnLFxuXHRcdDAsXG5cdFx0LSgxNzEgLSAxMzgpIC0gR3JpZC5vZmZzZXRZKTtcblx0dGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXIodGhpcyk7XG5cdHRoaXMuc3BlZWQgPSA1MDA7XG5cdHRoaXMuYW5nbGUgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxODApICogTWF0aC5QSSAvIDE4MDtcbn07XG5cbihmdW5jdGlvbiBQcm90b3R5cGUoKSB7XG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gTW92ZXMgdGhlIHN0YXIgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgYW5nbGUgYW5kIGxvd2VycyBvcGFjaXR5XG5cdCAqIEBwYXJhbSB7aW50fSBkdCAtIFRpbWUgc2luY2UgbGFzdCB1cGRhdGVcblx0ICovXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGR0KSB7XG5cdFx0dGhpcy54ICs9IHRoaXMuc3BlZWQgKiBNYXRoLmNvcyh0aGlzLmFuZ2xlKSAqIGR0O1xuXHRcdHRoaXMueSArPSB0aGlzLnNwZWVkICogTWF0aC5zaW4odGhpcy5hbmdsZSkgKiBkdDtcblx0XHR0aGlzLmFscGhhID0gTWF0aC5tYXgoMC4wMSwgdGhpcy5hbHBoYSAtIDEgKiBkdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW5kZXJzIHRoaXMgZW50aXR5IHRvIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtjb250ZXh0fSBjdHggLSBUaGUgY2FudmFzJ3MgY29udGV4dFxuXHQgKi9cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY3R4KSB7XG5cdFx0dGhpcy5yZW5kZXJlci5yZW5kZXIoY3R4KTtcblx0fTtcbn0pLmNhbGwoU3Rhci5wcm90b3R5cGUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gS2V5IGVudGl0eVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2ludH0gcm93IC0gVGhlIGluaXRpYWwgcm93XG4gKiBAcGFyYW0ge2ludH0gY29sIC0gVGhlIGluaXRpYWwgY29sdW1uXG4gKi9cbnZhciBFeHBsb3Npb24gPSBmdW5jdGlvbiBFeHBsb3Npb24ocm93LCBjb2wpIHtcblx0dGhpcy5zdGFycyA9IFtdO1xuXHR0aGlzLmFkZFN0YXJzKHJvdywgY29sLCAxMCk7XG59O1xuXG4oZnVuY3Rpb24gUHJvdG90eXBlKCkge1xuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIEFkZHMgdGhlIHN0YXJzXG5cdCAqIEBwYXJhbSB7aW50fSByb3cgLSBUaGUgeSBsb2NhdGlvblxuXHQgKiBAcGFyYW0ge2ludH0gY29sIC0gVGhlIHggbG9jYXRpb25cblx0ICogQHBhcmFtIHtpbnR9IHRvdGFsIC0gQW1vdW50IG9mIHN0YXJzXG5cdCAqL1xuXHR0aGlzLmFkZFN0YXJzID0gZnVuY3Rpb24gYWRkU3RhcnMocm93LCBjb2wsIHRvdGFsKSB7XG5cdFx0dmFyIGk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcblx0XHRcdHRoaXMuc3RhcnMucHVzaChuZXcgU3Rhcihyb3csIGNvbCkpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIE1vdmVzIGFsbCB0aGUgc3RhcnNcblx0ICogQHBhcmFtIHtpbnR9IGR0IC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZVxuXHQgKi9cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcblx0XHR2YXIgdG90YWwgPSB0aGlzLnN0YXJzLmxlbmd0aDtcblx0XHR2YXIgaTtcblx0XHRpZiAodG90YWwgPiAwKSB7XG5cdFx0XHRpZiAodGhpcy5zdGFyc1swXS5hbHBoYSA8PSAwLjAxKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnMgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zdGFyc1tpXS51cGRhdGUoZHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uIFJlbmRlcnMgdGhlIHN0YXJzIHRvIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtjb250ZXh0fSBjdHggLSBUaGUgY2FudmFzJ3MgY29udGV4dFxuXHQgKi9cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY3R4KSB7XG5cdFx0dmFyIHRvdGFsID0gdGhpcy5zdGFycy5sZW5ndGg7XG5cdFx0dmFyIGk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcblx0XHRcdHRoaXMuc3RhcnNbaV0ucmVuZGVyKGN0eCk7XG5cdFx0fVxuXHR9O1xufSkuY2FsbChFeHBsb3Npb24ucHJvdG90eXBlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwbGF5ZXIgPSBuZXcgUGxheWVyKCk7XG52YXIgdWkgPSBuZXcgVUkoKTtcbnZhciBzY2VuZSA9ICcnO1xudmFyIEFwcCA9IChmdW5jdGlvbiBBcHAoKSB7XG5cdHZhciBvblBsYXlDbGlja2VkID0gZnVuY3Rpb24gb25QbGF5Q2xpY2tlZCgpIHtcblx0XHRTY2VuZS5zdGFydEdhbWUodHJ1ZSk7XG5cdH07XG5cdHZhciBvblJlcGxheUNsaWNrZWQgPSBmdW5jdGlvbiBvblJlcGxheUNsaWNrZWQoKSB7XG5cdFx0U2NlbmUuc3RhcnRHYW1lKCk7XG5cdH07XG5cdHZhciBvbk1lbnVDbGlja2VkID0gZnVuY3Rpb24gb25NZW51Q2xpY2tlZCgpIHtcblx0XHRTY2VuZS5zdGFydE1lbnUoKTtcblx0fTtcblxuXHRFbC5hZGRMaXN0ZW5lcihFbC5nZXRFbGVtZW50cygnYnRuLXBsYXknKVswXSwgJ2NsaWNrJywgb25QbGF5Q2xpY2tlZCk7XG5cdEVsLmFkZExpc3RlbmVyKEVsLmdldEVsZW1lbnRzKCdidG4tcmVwbGF5JylbMF0sICdjbGljaycsIG9uUmVwbGF5Q2xpY2tlZCk7XG5cdEVsLmFkZExpc3RlbmVyKEVsLmdldEVsZW1lbnRzKCdidG4tbWVudScpLCAnY2xpY2snLCBvbk1lbnVDbGlja2VkKTtcblxuXHQvL1x0RGVmYXVsdCBzaG93IHRoZSBzdGFydCBtZW51XG5cdFNjZW5lLnN0YXJ0TWVudSgpO1xuXHQvL1x0U2NlbmUuc3RhcnRHYW1lKCk7XG59KSgpO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
